\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Некоторые вопросы программирования на языке Python}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Терминология}

Любой элемент данных, используемый в программе на Python, является \emph{объектом} \cite[\strbook{57}]{beazley:python-2010}.

Каждый объект имеет свою:
\begin{itemize}
	\item идентичность,
	
	\item тип (или класс),
	
	\item значение.
\end{itemize}

Например, когда в программе встречается интсрукция \verb|a = 42|, интерпретатор создает целочисленный объект со значением 42. Можно рассматривать идентичность объекта как указатель на область памяти, где находится объект, а индентификатор \texttt{a} -- как имя, которое ссылается на эту область памяти.

\emph{Тип объекта} сам по себе является \emph{объектом}, который называется \emph{классом объекта}. Все объекты в яызке Python могут быть отнесены к \emph{объектам первого класса} \cite[\strbook{61}]{beazley:python-2010}. Это означает, что все объекты, имеющие идентификатор, можно интерпретировать как \emph{данные}.

Тип \texttt{None} используется для представления пустых объектов (т.е. объектов, не имеющих значений). Этот объект возвращается функциями, которые не имеют явно возвращаемого значения. Объект \texttt{None} часто используется как значение по умолчанию для необязательных аргументов. Объкт \texttt{None} не имеет атрибутов и в логическом контексте оценивается как значение \texttt{False}.

\emph{Функции}, \emph{классы} и \emph{модули} в языке Python являются объектами, которыми можно манипулировать как обычными данными.

\emph{Свободные переменные} -- переменные, которые были определены в объемлющих функциях, а используются вложенными функциями \cite[\strbook{81}]{beazley:python-2010}.

Все функциональные возможности языка, включая присваивание значений переменным, определение функций и классов, импортирование модулей, реализованы в виде инструкций, обладающих равным положением со всеми остальными инструкциями.

\section{Передача параметров и возвращаемые значения}

Параметры функции, которые передаются ей при вызове, являются \emph{обычными именами}, ссылающимися на \emph{входные объекты}. Семантика передачи параметров в языке Python не имеет точного соответствия какому-либо одному способу, такому как <<передача по значению>> или <<передача по ссылке>>. Например, если функции передается неизменяемое значение, это выглядит, как передача аргумента по значению. Однако при передачи изменяемого объекта (такого как список или словарь), который модифицируется функцией, эти изменения будут отражаться на исходном объекте \cite[\strbook{133}]{beazley:python-2010}.

\section{Правила видимости в функциях}

При каждом вызове функции создается новое локальное пространство имен. Это пространство имен представляет локальное окружение, содержащее имена параметров функции, а также имена переменных, которым были присвоины значения в теле функции. Когда возникает необходимость отыскать имя, интерпретатор в первую очередь просматривает локальное пространство имен. Если искомое имя не было найдено, поиск продолжается в глобальном пространстве имен. Глобальным пространством имен для функций всегда является пространство имен модуля, в котором эта функция была определена. Если интерпретатор не найдет искомое имя в глобальном пространстве имен, поиск будет продолжен во встроенном пространстве имен. Если и эта попытка окажется неудачной, будет возбуждено исключение \texttt{NameError}.

В языке Python поддерживается возможность определять вложенные функции. Переменные во вложенных функциях привязаны к лексической области видимости. То есть поиск имени переменной начинается в \emph{локальной области видимости} и затем последовательно продолжается во всех \emph{объемлющих областях видимости} внешних функций, в направлении от внутренних к внешним. Если и в этих пространствах имен искомое имя не будет найдено, поиск будет продолжен в \emph{глобальном}, а затем во \emph{встроенном пространстве имен}, как и прежде.

При обращении к локальной переменной до того, как ей будет присвоено значение, возбуждается исключение \texttt{UnboundLocalError}
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
i = 0

def foo():
    i = i + 1
    print(i)  # UnboundLocalError
\end{lstlisting}

В функции \texttt{foo} переменная \texttt{i} определяется как локальная переменная, потому что внутри функции ей присваивается некоторое значение и отсутствует инструкция \texttt{global}). При этом инструкция присваивания \texttt{i = i + 1} пытается прочитать значение переменной \texttt{i} еще до того, как ей будет присвоено значение. 

Хотя в этом примере существует глобальная переменная \texttt{i}, она не используется для получения значения. Переменные в функциях могут быть \emph{либо локальными}, \emph{либо глобальными} и не могут произвольно изменять область видимости в середине функции. Например, нельзя считать, что переменная \texttt{i} в выражении \texttt{i = i + 1} в предыдущем фрагменте обращается к глобальной переменной \texttt{i}; при этом переменная \texttt{i} в вызове \texttt{print(i)} подразумевает локальную переменную \texttt{i}, созданную в предыдущей инструкции \cite[\strbook{136}]{beazley:python-2010}.

\section{Функции как объекты и замыкания}

\emph{Функции} в языке Python -- \emph{объекты первого класса}. Это означает, что они могут передаваться другим функциям в виде аргументов, сохраняться в структурах данных и возвращаеться функциями в виде результата \cite[\strbook{136}]{beazley:python-2010}.

Когда инструкции, составляющие функцию, упаковываются вместе с окружением, в котором они выполняются, получившийся объект называют \emph{замыканием}. Такое поведение объясняется наличием у каждой функции атрибута \verb|__globals__|, ссылающегося на глобальное пространство имен, в котором функция была определена. Это пространство имен всегда соответсвтует модулю, в котором функция была объявлена \cite[\strbook{137}]{beazley:python-2010}.

Когда функция используется как вложенная, в замыкание включается все ее окружение, необходимое для работы внутренней функции.


\section{Модули, пакеты и дистрибутивы}

Когда инструкция \texttt{import} впервые загружает модуль, она выполняет следующие три операции \cite[\strbook{189}]{beazley:python-2010}:
\begin{enumerate}
	\item Создает новое пространство имен, которое будет служить контейнером для всех объектов, определенных в соответствующем файле.
	
	\item Выполняет программный код в модуле внутри вновь созданного пространства имен.
	
	\item Создает в вызывающей программе имя, ссылающееся на пространство имен модуля. Это имя совпадает с именем модуля.
\end{enumerate}

Когда модуль импортируется впервые, он компилируется в байт-код и сохраняется на диске в файле с расширением \texttt{*.pyc}. При всех последующих обращениях к импортированию этого модуля интепретатор будет загружать скомпилированный байт-код, если только с момента создания байт-кода в файл \texttt{.py} не вносились изменения (в этом случае файл \texttt{.pyc} будет создан заново).

Автоматическая компиляция программного кода в файл с расширением \texttt{.pyc} производиться только при использовании инструкции \texttt{import}. При запуске программ из командной строки этот файл не создается.

\emph{Модули} в языке Python -- это \emph{объекты первого класса} \cite[\strbook{190}]{beazley:python-2010}. То есть они могут присваиваться переменным, помещаться в структуры данных, такие как списки, и передаваться между частями программы в виде элемента данных. Например
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import pandas as pd
\end{lstlisting}
просто создает переменную \texttt{pd}, которая ссылается на объект модуля \texttt{pandas}.

Важно подчеркнуть, что инструкция \texttt{import} выполнит все инструкции в загруженном файле. Если в дополнение к объявлению переменных, функций и классов в модуле содержаться некоторые вычисления и вывод результатов, то результаты будут выведены на экран в момент загрузки модуля.

Инструкция \texttt{import} может появляться в любом месте программы. Однако программный код любого модуля \emph{загружается} и \emph{выполняется} только один раз, независимо от количества инструкций \texttt{import}. 

\emph{Глобальным пространством имен} для функции всегда будет \emph{модуль}, в котором она была \underline{объявлена}, а не пространство имен, в которое эта функция была импортирована и откуда была вызвана \cite[\strbook{192}]{beazley:python-2010}.

Пакеты позволяют сгруппировать коллекцию модулей под общим именем пакета. Пакет создается как каталог с тем же именем, в котором создается файл с именем \verb|__init__.py|.

Например, пакет может иметь такую структуру
\begin{lstlisting}[
style = bash,
numbers = none
]
graphics/
    __init__.py
    primitives/
        __init__.py
        lines.py
        fill.py
        text.py
        ...
    graph2d/
        __init__.py
        plot2d.py
        ...
    graph3d/
        plot3d.py
        ...
    formats/
        __init__.py
        gif.py
        png.py
        tiff.py
        ...
\end{lstlisting}

Всякий раз когда какая-либо \emph{часть пакета импортируется впервые}, выполняется программный код в файле \verb|__init__.py| \cite[\strbook{198}]{beazley:python-2010}. Этот файл может быть пустым, но может также содержать программный код, выполняющий инициализацию пакета. Выполнены будут все файлы \verb|__init__.py|, которые встретятся инструкции \texttt{import} в процессе ее выполнения.

То есть инструкция
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import graphics.primitives.fill
\end{lstlisting}
сначала выполнит файл \verb|__init__.py| в каталоге \texttt{graphics}, а затем файл \verb|__init__.py| в каталоге \texttt{primitives}.

При импортировании модулей из пакета следует быть особенно внимательными и не использовать инструкцию вида \texttt{import module}, так как в Python 3, инструкция \texttt{import} предполагает, что указан абсолютный путь, и будет пытаться загрузить модуль из стандартной библиотеки. Использование инструкции импортирования по относительному пути более четко говорит о ваших намерениях.

Возможность импортирования по относительному пути можно также использовать для загрузки модулей, находящихся в других каталогах того же пакета. Например, если в модуле \texttt{Graphics.Graph2d.plot2d} потребуется импортировать модуль \texttt{Graphics.Primitives.lines}, инструкция импорта будет иметь следующий вид
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from ..primitives import lines  # так можно!
\end{lstlisting}

В этом примере символы \texttt{..} перемещают точку начала поиска на уровень выше в дереве каталогов, а имя \texttt{primiitves} перемещает ее вниз, в другой каталог пакета.

Импорт по относительному пути может выполняться только при использовании инструкции импортирования вида
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from module import symbol
\end{lstlisting}

То есть такие конструкции, как
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import ..primitives.lines  # Ошибка!
import .lines  # Ошибка!
\end{lstlisting}
будут рассматриваться как синтаксическая ошибка.

Кроме того, имя \texttt{symbol} должно быть допустимым идентификатором. Поэтому такая инструкция, как 
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from .. import primitives.lines  # Ошибка!
\end{lstlisting}
также считается ошибочной.

Наконец, импортирование по относительному пути может выполняться только для модулей в пакете; не допускается использовать эту возможность для ссылки на модули, которые просто находятся в другом каталоге файловой системы.

Импортирование по одному только имени пакета не приводит к импортированию всех модулей, содержащихся в этом пакете \cite[\strbook{199}]{beazley:python-2010}, однако, так как инструкция \texttt{import graphics} выполнит файл \verb|__init__.py| в каталоге \texttt{graphics}, в него можно добавить инструкции импортирования по относительному пути, которые автоматически загрузят все модули, как показано ниже
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# graphics/__init__.py
from . import primitives, graph2d, graph3d

# graphics/primitives/__init__.py
from . import lines, fill, text
...
\end{lstlisting}

Для того чтобы сделать функции модулей подпакетов доступными из-под имени подпакетов (без обращения к модулям, в которых были объявлены эти функции), можно относительный импорт организовать следующим образом
\begin{lstlisting}[
style = ironpython,
numbers =  none
]
# graphics/primitives/__init__.py
from .fill import make_fill
from .lines import make_lines
...
\end{lstlisting}

Теперь вызвать, например, функцию \texttt{make\_fill} модуля \texttt{fill} подпакета \texttt{primitives} можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from graphics.primitives import make_fill
# вместо
from graphics.primitives.fill import make_fill
\end{lstlisting}

Наконец, когда интерпретатор импортирует пакет, он объявляет специальную переменную \verb|__path__|, содержащую список каталогов, в которых выполняется поиск модулей пакета (\verb|__path__| представляет собой аналог списка \texttt{sys.path} для пакета). Переменная \verb|__path__| доступна для программного кода в файлах \verb|__init__.py| и изначально содержит единственный элемент с именем каталога пакета.

При необходимости пакет может добавлять в список \verb|__path__| дополнительные каталоги, чтобы изменить путь поиска модулей. Это может потребоваться в случае сложной организации дерева каталогов пакета в файловой системе, которая не совпадает с иерархией пакета.

\section{Некоторые приемы}

\subsection{Вычисления со словарями}

Рассмотрим словарь, который отображает тикеры на цены
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d = {
    "ACME": 45.23,
    "AAPL": 612.78,
    "IBM": 205.55,
    "HPQ": 37.20,
    "FB": 10.75,
}
\end{lstlisting}

Чтобы найти наименьшую/наибольшую цены с тикером можно обратить ключи и значения, а затем воспользоваться функций \texttt{zip()}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
min(zip(d.values(), d.keys()))  # (10.75, "FB")
max(zip(d.values(), d.keys()))  # (612.78, "AAPL")
\end{lstlisting}

Важно иметь в виду, что функция \texttt{zip()} создает итератор, по которому можно пройти только один раз.

Использование функции \texttt{zip()} решает задачу путем <<обращения>> словаря в последовательность пар (value, key). 

Однако, вариант с функцией \texttt{zip()} требует большего времени, чем вариант на цикле
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%timeit -n 1_000_000
# 639 ns +/- 3.04 ns per loop (mean +/- std. dev. of 7 runs, 1,000,000 loops each)
min(zip(d.values(), d.values()))  

%%timeit -n 1_000_000
# 576 ns +/- 1.4 ns per loop (mean +/- std. dev. of 7 runs, 1,000,000 loops each)
def find_min_pair(d: t.Dict[str, float]) -> t.Tuple[float, str]:
    min_value = float("inf")
    for key, value in d.items():
        if value < min_value:
            min_value = d[key]
            min_key = key
    return (min_value, min_key)
\end{lstlisting} 

Пусть есть два словаря. Требуется выяснить, что у них общего
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d1 = {"x": 1, "y": 2, "z": 3}
d2 = {"w": 10, "x": 11, "y": 2}

# Найти общие ключи
d1.keys() & d2.keys()

# Находим ключи, которые есть в d1, но которых нет в d2
d1.keys() - d2.keys()

# Находим общие пары (key, value)
d1.items() & d2.items()  # {("y", 2)}
\end{lstlisting}

Словарь -- это отображение множества ключей на мнгожество значений. Метод словаря \texttt{keys()} возвращает \emph{объект ключей словаря} \texttt{dict\_keys}. Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над \emph{множествами}: объединение, пересечение и разность. Так что, если требуется выполнить этот набор операций над ключами словаря, то можно использовать объект ключей словаря напрямую, без предварительного конвертирования во множество \cite[\strbook{35}]{beazley:python_cookbook-2019}, т.е.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d1.keys() & d2.keys()  # {"x", "y"}
# вместо
set(d1.keys()) & set(d2.keys())  # {"x", "y"}
# или
set(d1.keys()).intersection(set(d2.keys()))  # {"x", "y"}
\end{lstlisting}

Найти пересечение индексов двух серий можно было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
ser1 = pd.Series(d1, name="ser1")
ser2 = pd.Series(d2, name="ser2")

pd.merge(
    ser1,
    ser2,
    left_index=True,
    right_index=True,
    how="inner"
).index.to_list()  # ["x", "y"]
\end{lstlisting}

\subsection{Удаление дубликатов из последовательности}

Вы хотите ислкючить дублирующиеся значения из последовательности, но при этом сохранить порядрк следования оставшихся элементов.

Если значения в последовательности являютеся хешируемыми, задача может быть легко решена с использованием множества и генератора
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%timeit -n 100_000
# 984 ns +/- 17.6 ns per loop (mean +/- std. dev. of 7 runs, 100,000 loops each)
def dedupe(items: t.Iterable[int]) -> t.Iterable[int]:
    seen: t.Set[int] = set()
    for item in items:
        if item not in seen:
            yield item  # отдать элемент
            seen.add(item)  # обновить множество
            
lst = [1, 5, 2, 1, 9, 1, 5, 10]
list(dedupe(lst))  # [1, 5, 2, 9, 10]
\end{lstlisting}

Или так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
%%timeit -n 100_000
# 663 ns +/- 26.2 ns per loop (mean +/- std. dev. of 7 runs, 100,000 loops each)
def dedupe_list(items: t.Iterable[int]) -> t.Iterable[int]:
    seen: t.Iterable[int] = []
    for item in items:
        if item not in seen:
            seen.append(item)
    return seen
\end{lstlisting}

\subsection{Сортировка списка словарей по общему ключу}

У вас есть список словарей, и вы хотите отсортировать записи согласно одному или более полям. Сортировка структур этого типа легко выполняется с помощью функции \texttt{operator.itemgetter}. Именованный аргумент \texttt{key} должен быть \emph{вызываемым объектом} (т.е. объектом, в котором реализован метод \verb|__call__|). Функция \texttt{itemgetter()} создает такой вызываемый объект
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from operator import itergetter

records: t.Iterable[dict] = [
    {"fname": "Brian", "lname": "Jones", "uid": 1003},
    {"fname": "David", "lname": "Beazley", "uid": 1002},
    {"fname": "John", "lname": "Cleese", "uid": 1004},
]

# аргумент key ожидает получить вызываемый объект
sorted(records, key=itemgetter("fname"))
sorted(records, key=itergetter("uid"))
# то же, что и
sorted(records, key=lambda record: record["fname"])
sorted(records, key=lambda record: record["uid"])
\end{lstlisting}

Функция \texttt{itemgetter()} может принимать несколько полей
\begin{lstlisting}[
style = ironpython,
numbers = none
]
sorted(records, key=itemtegger("lname", "fname"))
\end{lstlisting}

Эту технику можно применять и к функциям \texttt{min}, \texttt{max}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# найти строку с наименьшим значением идентификационного номера
min(records, key=itemgetter("uid"))
\end{lstlisting}

\subsection{Отображение имен на последовательность элементов}

У вас есть код, который осуществляет доступ к элементам в списке или кортеже по позиции. Однако такой подход часто программу нечитабельной. 

\texttt{collections.namedtuple()} -- фабричный метод, который возвращает подкласс стандартного типа Python -- tuple. Метод возвращает класс, который может порождать экземпляры
\begin{lstlisting}[
style = ironpython,
numbers = none
]
Person = namedtuple("Person", ["name", "age", "job"])
leor = Person(name="Leor", age=36, job="DS")
\end{lstlisting}

Хотя экземпляр \texttt{namedtuple} выглядит так же, как и обычный экземпляр класса, он взаимозаменям с кортежем и поддерживает все обычные операции кортежей, такие как индексирование и распаковка
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
name, age, job = leor
\end{lstlisting}

Возможное использование именнованного кортежа -- замена словаря, который требует больше места для хранения. Так что, если создаете крупные структуры данных с использованием словарей, применение именованных кортежей будет более эффективным. Однако, именованные кортежи неизменяемы в отличие от словарей.

Если вам нужно изменить любой из атрибутов, это может быть сделано с помощью метода \verb|_replace()|, которым обладают экземпляры именованных кортежей.

Тонкость использования метода \verb|_replace()| заключается в том, что он может стать удобным способом наполнить значениями именованный кортеж, у которого есть опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип кортежа, содержащий значения по умолчанию, а затем применяйте \verb|_replace()| для создания новых экземпляров с замененными значениями
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collection import namedtuple

Stock = namedtuple("Stock", ["name", "shares", "price", "date", "time"])
stock_prototype = Stock("", 0, 0.0, None, None)

def dict_to_stock(s):
    return stock_prototype._replace(**s)
\end{lstlisting}

\section{Строки и текст}

\subsection{Разрезание строк различными разделителями}

Нужно разделить строку на поля, но разделители (и пробелы вокруг них) внтури строки разные
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import re
line = "asdf fjdk; afed, fjek,asdf,     foo"
re.split(r"[;,\s]\s*", line)
\end{lstlisting}





\section{Профилирование и замеры времени выполнения}

При проведении измерений производительности нужно помнить, что любые результаты будут приблизительными. Функция \texttt{time.perf\_counter()} предоставляет наиболее точный таймер из доступных. Однако она все-таки измеряет \emph{внешнее время}, и {\color{red}на результаты влияют различные факторы, такие как нагруженность компьютера}.

Если вы хотите получить время обработки, а не внешнее время, используйте \texttt{time.process\_time()} \cite[\strbook{574}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps

def timethis(func):
    @wraps(func)
    def wrapper(*args, **kwrags):
        start = time.process_time()  # <- NB
        r = func(*args, **kwargs)
        stop = time.process_time()  # <- NB
        print(f"{func.__module__}.{func.__name__} : {end - start}")
        return r
    return wrapper
    
@timethis
def countdown(n):
    while n > 0:
        n -= 1

countdown(100000)
\end{lstlisting}

Чтобы подсчитать время выполнения блока инструкций, можно определить менеджер контекста
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from contexlib import contexmanager

@contextmanager
def timeblock(label):
    start = time.process_time()
    try:
       yield
    finally:
        end = time.process_time()
        print(f"{label} : {end - start}")
        
with timeblock("counting"):
	n = 100000
	while n > 0:
	    n -= 1
	# counting: 1.55555
\end{lstlisting}





% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{beazley:python-2010}{\emph{Бизли Д.} Python. Подробный справочник. -- СПб.: Символ-Плюс, 2010. -- 864 с.}
	
	\bibitem{beazley:python_cookbook-2019}{\emph{Бизли Д.} Python. Книга рецептов. -- М.: ДМК Пресс., 2019. -- 648 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
