\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Некоторые вопросы программирования на языке Python и приемы работы со специализированными библиотеками}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Терминология}

Любой элемент данных, используемый в программе на Python, является \emph{объектом} \cite[\strbook{57}]{beazley:python-2010}.

Каждый объект имеет свою:
\begin{itemize}
	\item идентичность,
	
	\item тип (или класс),
	
	\item значение.
\end{itemize}

Например, когда в программе встречается интсрукция \verb|a = 42|, интерпретатор создает целочисленный объект со значением 42. Можно рассматривать идентичность объекта как указатель на область памяти, где находится объект, а индентификатор \texttt{a} -- как имя, которое ссылается на эту область памяти.

\emph{Тип объекта} сам по себе является \emph{объектом}, который называется \emph{классом объекта}. Все объекты в яызке Python могут быть отнесены к \emph{объектам первого класса} \cite[\strbook{61}]{beazley:python-2010}. Это означает, что все объекты, имеющие идентификатор, можно интерпретировать как \emph{данные}.

Тип \texttt{None} используется для представления пустых объектов (т.е. объектов, не имеющих значений). Этот объект возвращается функциями, которые не имеют явно возвращаемого значения. Объект \texttt{None} часто используется как значение по умолчанию для необязательных аргументов. Объкт \texttt{None} не имеет атрибутов и в логическом контексте оценивается как значение \texttt{False}.

\emph{Функции}, \emph{классы} и \emph{модули} в языке Python являются объектами, которыми можно манипулировать как обычными данными.

\emph{Свободные переменные} -- переменные, которые были определены в объемлющих функциях, а используются вложенными функциями \cite[\strbook{81}]{beazley:python-2010}.

Все функциональные возможности языка, включая присваивание значений переменным, определение функций и классов, импортирование модулей, реализованы в виде инструкций, обладающих равным положением со всеми остальными инструкциями.

\section{Передача параметров и возвращаемые значения}

Параметры функции, которые передаются ей при вызове, являются \emph{обычными именами}, ссылающимися на \emph{входные объекты}. Семантика передачи параметров в языке Python не имеет точного соответствия какому-либо одному способу, такому как <<передача по значению>> или <<передача по ссылке>>. Например, если функции передается неизменяемое значение, это выглядит, как передача аргумента по значению. Однако при передачи изменяемого объекта (такого как список или словарь), который модифицируется функцией, эти изменения будут отражаться на исходном объекте \cite[\strbook{133}]{beazley:python-2010}.

\section{Правила видимости в функциях}

При каждом вызове функции создается новое локальное пространство имен. Это пространство имен представляет локальное окружение, содержащее имена параметров функции, а также имена переменных, которым были присвоины значения в теле функции. Когда возникает необходимость отыскать имя, интерпретатор в первую очередь просматривает локальное пространство имен. Если искомое имя не было найдено, поиск продолжается в глобальном пространстве имен. Глобальным пространством имен для функций всегда является пространство имен модуля, в котором эта функция была определена. Если интерпретатор не найдет искомое имя в глобальном пространстве имен, поиск будет продолжен во встроенном пространстве имен. Если и эта попытка окажется неудачной, будет возбуждено исключение \texttt{NameError}.

В языке Python поддерживается возможность определять вложенные функции. Переменные во вложенных функциях привязаны к лексической области видимости. То есть поиск имени переменной начинается в \emph{локальной области видимости} и затем последовательно продолжается во всех \emph{объемлющих областях видимости} внешних функций, в направлении от внутренних к внешним. Если и в этих пространствах имен искомое имя не будет найдено, поиск будет продолжен в \emph{глобальном}, а затем во \emph{встроенном пространстве имен}, как и прежде.

При обращении к локальной переменной до того, как ей будет присвоено значение, возбуждается исключение \texttt{UnboundLocalError}
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
i = 0

def foo():
    i = i + 1
    print(i)  # UnboundLocalError
\end{lstlisting}

В функции \texttt{foo} переменная \texttt{i} определяется как локальная переменная, потому что внутри функции ей присваивается некоторое значение и отсутствует инструкция \texttt{global}). При этом инструкция присваивания \texttt{i = i + 1} пытается прочитать значение переменной \texttt{i} еще до того, как ей будет присвоено значение. 

Хотя в этом примере существует глобальная переменная \texttt{i}, она не используется для получения значения. Переменные в функциях могут быть \emph{либо локальными}, \emph{либо глобальными} и не могут произвольно изменять область видимости в середине функции. Например, нельзя считать, что переменная \texttt{i} в выражении \texttt{i = i + 1} в предыдущем фрагменте обращается к глобальной переменной \texttt{i}; при этом переменная \texttt{i} в вызове \texttt{print(i)} подразумевает локальную переменную \texttt{i}, созданную в предыдущей инструкции \cite[\strbook{136}]{beazley:python-2010}.

\section{Функции как объекты и замыкания}

\emph{Функции} в языке Python -- \emph{объекты первого класса}. Это означает, что они могут передаваться другим функциям в виде аргументов, сохраняться в структурах данных и возвращаеться функциями в виде результата \cite[\strbook{136}]{beazley:python-2010}.

Когда инструкции, составляющие функцию, упаковываются вместе с окружением, в котором они выполняются, получившийся объект называют \emph{замыканием}. Такое поведение объясняется наличием у каждой функции атрибута \verb|__globals__|, ссылающегося на глобальное пространство имен, в котором функция была определена. Это пространство имен всегда соответсвтует модулю, в котором функция была объявлена \cite[\strbook{137}]{beazley:python-2010}.

Когда функция используется как вложенная, в замыкание включается все ее окружение, необходимое для работы внутренней функции.


\section{Модули, пакеты и дистрибутивы}

Когда инструкция \texttt{import} впервые загружает модуль, она выполняет следующие три операции \cite[\strbook{189}]{beazley:python-2010}:
\begin{enumerate}
	\item Создает новое пространство имен, которое будет служить контейнером для всех объектов, определенных в соответствующем файле.
	
	\item Выполняет программный код в модуле внутри вновь созданного пространства имен.
	
	\item Создает в вызывающей программе имя, ссылающееся на пространство имен модуля. Это имя совпадает с именем модуля.
\end{enumerate}

Когда модуль импортируется впервые, он компилируется в байт-код и сохраняется на диске в файле с расширением \texttt{*.pyc}. При всех последующих обращениях к импортированию этого модуля интепретатор будет загружать скомпилированный байт-код, если только с момента создания байт-кода в файл \texttt{.py} не вносились изменения (в этом случае файл \texttt{.pyc} будет создан заново).

Автоматическая компиляция программного кода в файл с расширением \texttt{.pyc} производиться только при использовании инструкции \texttt{import}. При запуске программ из командной строки этот файл не создается.

\emph{Модули} в языке Python -- это \emph{объекты первого класса} \cite[\strbook{190}]{beazley:python-2010}. То есть они могут присваиваться переменным, помещаться в структуры данных, такие как списки, и передаваться между частями программы в виде элемента данных. Например
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import pandas as pd
\end{lstlisting}
просто создает переменную \texttt{pd}, которая ссылается на объект модуля \texttt{pandas}.

Важно подчеркнуть, что инструкция \texttt{import} выполнит все инструкции в загруженном файле. Если в дополнение к объявлению переменных, функций и классов в модуле содержаться некоторые вычисления и вывод результатов, то результаты будут выведены на экран в момент загрузки модуля.

Инструкция \texttt{import} может появляться в любом месте программы. Однако программный код любого модуля \emph{загружается} и \emph{выполняется} только один раз, независимо от количества инструкций \texttt{import}. 

\emph{Глобальным пространством имен} для функции всегда будет \emph{модуль}, в котором она была \underline{объявлена}, а не пространство имен, в которое эта функция была импортирована и откуда была вызвана \cite[\strbook{192}]{beazley:python-2010}.

Пакеты позволяют сгруппировать коллекцию модулей под общим именем пакета. Пакет создается как каталог с тем же именем, в котором создается файл с именем \verb|__init__.py|.

Например, пакет может иметь такую структуру
\begin{lstlisting}[
style = bash,
numbers = none
]
graphics/
    __init__.py
    primitives/
        __init__.py
        lines.py
        fill.py
        text.py
        ...
    graph2d/
        __init__.py
        plot2d.py
        ...
    graph3d/
        plot3d.py
        ...
    formats/
        __init__.py
        gif.py
        png.py
        tiff.py
        ...
\end{lstlisting}

Всякий раз когда какая-либо \emph{часть пакета импортируется впервые}, выполняется программный код в файле \verb|__init__.py| \cite[\strbook{198}]{beazley:python-2010}. Этот файл может быть пустым, но может также содержать программный код, выполняющий инициализацию пакета. Выполнены будут все файлы \verb|__init__.py|, которые встретятся инструкции \texttt{import} в процессе ее выполнения.

То есть инструкция
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import graphics.primitives.fill
\end{lstlisting}
сначала выполнит файл \verb|__init__.py| в каталоге \texttt{graphics}, а затем файл \verb|__init__.py| в каталоге \texttt{primitives}.

При импортировании модулей из пакета следует быть особенно внимательными и не использовать инструкцию вида \texttt{import module}, так как в Python 3, инструкция \texttt{import} предполагает, что указан абсолютный путь, и будет пытаться загрузить модуль из стандартной библиотеки. Использование инструкции импортирования по относительному пути более четко говорит о ваших намерениях.

Возможность импортирования по относительному пути можно также использовать для загрузки модулей, находящихся в других каталогах того же пакета. Например, если в модуле \texttt{Graphics.Graph2d.plot2d} потребуется импортировать модуль \texttt{Graphics.Primitives.lines}, инструкция импорта будет иметь следующий вид
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from ..primitives import lines  # так можно!
\end{lstlisting}

В этом примере символы \texttt{..} перемещают точку начала поиска на уровень выше в дереве каталогов, а имя \texttt{primiitves} перемещает ее вниз, в другой каталог пакета.

Импорт по относительному пути может выполняться только при использовании инструкции импортирования вида
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from module import symbol
\end{lstlisting}

То есть такие конструкции, как
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import ..primitives.lines  # Ошибка!
import .lines  # Ошибка!
\end{lstlisting}
будут рассматриваться как синтаксическая ошибка.

Кроме того, имя \texttt{symbol} должно быть допустимым идентификатором. Поэтому такая инструкция, как 
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from .. import primitives.lines  # Ошибка!
\end{lstlisting}
также считается ошибочной.

Наконец, импортирование по относительному пути может выполняться только для модулей в пакете; не допускается использовать эту возможность для ссылки на модули, которые просто находятся в другом каталоге файловой системы.

Импортирование по одному только имени пакета не приводит к импортированию всех модулей, содержащихся в этом пакете \cite[\strbook{199}]{beazley:python-2010}, однако, так как инструкция \texttt{import graphics} выполнит файл \verb|__init__.py| в каталоге \texttt{graphics}, в него можно добавить инструкции импортирования по относительному пути, которые автоматически загрузят все модули, как показано ниже
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# graphics/__init__.py
from . import primitives, graph2d, graph3d

# graphics/primitives/__init__.py
from . import lines, fill, text
...
\end{lstlisting}

Для того чтобы сделать функции модулей подпакетов доступными из-под имени подпакетов (без обращения к модулям, в которых были объявлены эти функции), можно относительный импорт организовать следующим образом
\begin{lstlisting}[
style = ironpython,
numbers =  none
]
# graphics/primitives/__init__.py
from .fill import make_fill
from .lines import make_lines
...
\end{lstlisting}

Теперь вызвать, например, функцию \texttt{make\_fill} модуля \texttt{fill} подпакета \texttt{primitives} можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from graphics.primitives import make_fill
# вместо
from graphics.primitives.fill import make_fill
\end{lstlisting}

Грубо говоря, можно считать, что элементы расположенные справа от инструкции \texttt{import} в файле \verb|__init__.py| будут как бы замещать имя модуля \verb|__init__.py| в пути до этого файла, т.е.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# graphics/formats/__init__.py
from .png import print_png
from .jpg import print_jpg

# В сессии
>>> import graphics.formats.print_png
\end{lstlisting}

Переменная \verb|__all__| управляет логикой работы инструкции \verb|import *| и проявляется только если пользователь модуля/пакета использует прием <<импортировать все>>. Если известен путь до нужного модуля, то переменная \verb|__all__| не помешает. Если определить \verb|__all__| как пустой список, ничего экспортироваться не будет \cite[\strbook{395}]{beazley:python_cookbook-2019}.

Важное замечание: относительное импортирование работает только для модулей, которые размещены внутри подходящего пакета. В частности, оно не работает внутри простых модулей, размещенных на верхнем уровне скриптов. Оно также не работает, если \emph{части пакета} исполняются напрямую, \emph{как скрипты}, например \cite[\strbook{396}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ python mypackage/A/spam.py  # Относительное импортирование не работает!!!
\end{lstlisting}

С другой стороны, если вы выполните предыдущий скрипт, передав Python опцию \verb|-m|, относительное импортирование будет работать правильно
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ python -m mypackage/A/spam  # Относительное импортирование работает!
\end{lstlisting}

\remark{
Относительный импорт не работает, если части пакета исполняются напрямую, как скрипты. Но ситуацияю можно исправить, если воспользоваться опцией \texttt{-m}
}




Наконец, когда интерпретатор импортирует пакет, он объявляет специальную переменную \verb|__path__|, содержащую список каталогов, в которых выполняется поиск модулей пакета (\verb|__path__| представляет собой аналог списка \texttt{sys.path} для пакета). Переменная \verb|__path__| доступна для программного кода в файлах \verb|__init__.py| и изначально содержит единственный элемент с именем каталога пакета.

При необходимости пакет может добавлять в список \verb|__path__| дополнительные каталоги, чтобы изменить путь поиска модулей. Это может потребоваться в случае сложной организации дерева каталогов пакета в файловой системе, которая не совпадает с иерархией пакета.

\subsection{Создание отдельных каталогов с кодом для импорта под общим пространством имен}

Требуется определить пакет Python высшего уровня, который будет служить пространством имен для большой коллекции отдельно поддерживаемых подпакетов.

Нужно организовать код так же, как и в обычном пакете Python, но опустить файлы \verb|__init__.py| в каталогах, где компоненты будут объединяться. Пример \cite[\strbook{399}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
foo-package/
    spam/
        blah.py
        
bar-package/
    spam/
        grok.py
\end{lstlisting}

В этих каталогах имя \texttt{spam} используется в качестве общего пространства имен. Обратите внимание, что файл \verb|__init__.py| отсутствует в обоих каталогах.

Теперь, если добавить оба пакета \texttt{foo-package} и \texttt{bar-package} к пути поиска модулей Python и попробуете импортировать
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import sys
sys.path.extend(["foo-package", "bar-package"])
import spam.blah
import spam.grok
\end{lstlisting}

Для разных каталога пакетов слились вместе. Механизм, который здесь работает, известен под названием <<пакет пространства имен>>. По сути, пакет пространства имен -- это специальный пакет, разработанный для слияния различных каталогов с кодом под общим пространством имен.

Ключ к созданию пакета пространства имен -- отсутствие файлов \verb|__init__.py| в каталоге высшего уровня, который служит общим пространством имен. Вместо того чтобы выкинуть ошибку, интерпретатор начинает создавать список всех каталогов, которые содержит совпадающее имя пакета. Затем создается специальный модуль-пакет пространства имен, и в его переменной \verb|__path__| сохраняется доступная только для чтения копия списка каталогов.





\section{Некоторые приемы}

\subsection{Вычисления со словарями}

Рассмотрим словарь, который отображает тикеры на цены
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d = {
    "ACME": 45.23,
    "AAPL": 612.78,
    "IBM": 205.55,
    "HPQ": 37.20,
    "FB": 10.75,
}
\end{lstlisting}

Чтобы найти наименьшую/наибольшую цены с тикером можно обратить ключи и значения, а затем воспользоваться функций \texttt{zip()}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
min(zip(d.values(), d.keys()))  # (10.75, "FB")
max(zip(d.values(), d.keys()))  # (612.78, "AAPL")
\end{lstlisting}

Важно иметь в виду, что функция \texttt{zip()} создает итератор, по которому можно пройти только один раз.

Использование функции \texttt{zip()} решает задачу путем <<обращения>> словаря в последовательность пар (value, key). 

Однако, вариант с функцией \texttt{zip()} требует большего времени, чем вариант на цикле
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%timeit -n 1_000_000
# 639 ns +/- 3.04 ns per loop (mean +/- std. dev. of 7 runs, 1,000,000 loops each)
min(zip(d.values(), d.values()))  

%%timeit -n 1_000_000
# 576 ns +/- 1.4 ns per loop (mean +/- std. dev. of 7 runs, 1,000,000 loops each)
def find_min_pair(d: t.Dict[str, float]) -> t.Tuple[float, str]:
    min_value = float("inf")
    for key, value in d.items():
        if value < min_value:
            min_value = d[key]
            min_key = key
    return (min_value, min_key)
\end{lstlisting} 

Пусть есть два словаря. Требуется выяснить, что у них общего
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d1 = {"x": 1, "y": 2, "z": 3}
d2 = {"w": 10, "x": 11, "y": 2}

# Найти общие ключи
d1.keys() & d2.keys()

# Находим ключи, которые есть в d1, но которых нет в d2
d1.keys() - d2.keys()

# Находим общие пары (key, value)
d1.items() & d2.items()  # {("y", 2)}
\end{lstlisting}

Словарь -- это отображение множества ключей на мнгожество значений. Метод словаря \texttt{keys()} возвращает \emph{объект ключей словаря} \texttt{dict\_keys}. Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над \emph{множествами}: объединение, пересечение и разность. Так что, если требуется выполнить этот набор операций над ключами словаря, то можно использовать объект ключей словаря напрямую, без предварительного конвертирования во множество \cite[\strbook{35}]{beazley:python_cookbook-2019}, т.е.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d1.keys() & d2.keys()  # {"x", "y"}
# вместо
set(d1.keys()) & set(d2.keys())  # {"x", "y"}
# или
set(d1.keys()).intersection(set(d2.keys()))  # {"x", "y"}
\end{lstlisting}

Найти пересечение индексов двух серий можно было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
ser1 = pd.Series(d1, name="ser1")
ser2 = pd.Series(d2, name="ser2")

pd.merge(
    ser1,
    ser2,
    left_index=True,
    right_index=True,
    how="inner"
).index.to_list()  # ["x", "y"]
\end{lstlisting}

\subsection{Удаление дубликатов из последовательности}

Вы хотите ислкючить дублирующиеся значения из последовательности, но при этом сохранить порядрк следования оставшихся элементов.

Если значения в последовательности являютеся хешируемыми, задача может быть легко решена с использованием множества и генератора
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%timeit -n 100_000
# 984 ns +/- 17.6 ns per loop (mean +/- std. dev. of 7 runs, 100,000 loops each)
def dedupe(items: t.Iterable[int]) -> t.Iterable[int]:
    seen: t.Set[int] = set()
    for item in items:
        if item not in seen:
            yield item  # отдать элемент
            seen.add(item)  # обновить множество
            
lst = [1, 5, 2, 1, 9, 1, 5, 10]
list(dedupe(lst))  # [1, 5, 2, 9, 10]
\end{lstlisting}

Или так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
%%timeit -n 100_000
# 663 ns +/- 26.2 ns per loop (mean +/- std. dev. of 7 runs, 100,000 loops each)
def dedupe_list(items: t.Iterable[int]) -> t.Iterable[int]:
    seen: t.Iterable[int] = []
    for item in items:
        if item not in seen:
            seen.append(item)
    return seen
\end{lstlisting}

\subsection{Сортировка списка словарей по общему ключу}

У вас есть список словарей, и вы хотите отсортировать записи согласно одному или более полям. Сортировка структур этого типа легко выполняется с помощью функции \texttt{operator.itemgetter}. Именованный аргумент \texttt{key} должен быть \emph{вызываемым объектом} (т.е. объектом, в котором реализован метод \verb|__call__|). Функция \texttt{itemgetter()} создает такой вызываемый объект
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from operator import itergetter

records: t.Iterable[dict] = [
    {"fname": "Brian", "lname": "Jones", "uid": 1003},
    {"fname": "David", "lname": "Beazley", "uid": 1002},
    {"fname": "John", "lname": "Cleese", "uid": 1004},
]

# аргумент key ожидает получить вызываемый объект
sorted(records, key=itemgetter("fname"))
sorted(records, key=itergetter("uid"))
# то же, что и
sorted(records, key=lambda record: record["fname"])
sorted(records, key=lambda record: record["uid"])
\end{lstlisting}

Функция \texttt{itemgetter()} может принимать несколько полей
\begin{lstlisting}[
style = ironpython,
numbers = none
]
sorted(records, key=itemtegger("lname", "fname"))
\end{lstlisting}

Эту технику можно применять и к функциям \texttt{min}, \texttt{max}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# найти строку с наименьшим значением идентификационного номера
min(records, key=itemgetter("uid"))
\end{lstlisting}

\subsection{Отображение имен на последовательность элементов}

У вас есть код, который осуществляет доступ к элементам в списке или кортеже по позиции. Однако такой подход часто программу нечитабельной. 

\texttt{collections.namedtuple()} -- фабричный метод, который возвращает подкласс стандартного типа Python -- tuple. Метод возвращает класс, который может порождать экземпляры
\begin{lstlisting}[
style = ironpython,
numbers = none
]
Person = namedtuple("Person", ["name", "age", "job"])
leor = Person(name="Leor", age=36, job="DS")
\end{lstlisting}

Хотя экземпляр \texttt{namedtuple} выглядит так же, как и обычный экземпляр класса, он взаимозаменям с кортежем и поддерживает все обычные операции кортежей, такие как индексирование и распаковка
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
name, age, job = leor
\end{lstlisting}

Возможное использование именнованного кортежа -- замена словаря, который требует больше места для хранения. Так что, если создаете крупные структуры данных с использованием словарей, применение именованных кортежей будет более эффективным. Однако, именованные кортежи неизменяемы в отличие от словарей.

Если вам нужно изменить любой из атрибутов, это может быть сделано с помощью метода \verb|_replace()|, которым обладают экземпляры именованных кортежей.

Тонкость использования метода \verb|_replace()| заключается в том, что он может стать удобным способом наполнить значениями именованный кортеж, у которого есть опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип кортежа, содержащий значения по умолчанию, а затем применяйте \verb|_replace()| для создания новых экземпляров с замененными значениями
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collection import namedtuple

Stock = namedtuple("Stock", ["name", "shares", "price", "date", "time"])
stock_prototype = Stock("", 0, 0.0, None, None)

def dict_to_stock(s):
    return stock_prototype._replace(**s)
\end{lstlisting}

\section{Строки и текст}

\subsection{Разрезание строк различными разделителями}

Нужно разделить строку на поля, но разделители (и пробелы вокруг них) внтури строки разные
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import re
line = "asdf fjdk; afed, fjek,asdf,     foo"
re.split(r"[;,\s]\s*", line)
\end{lstlisting}





\section{Профилирование и замеры времени выполнения}

При проведении измерений производительности нужно помнить, что любые результаты будут приблизительными. Функция \texttt{time.perf\_counter()} предоставляет наиболее точный таймер из доступных. Однако она все-таки измеряет \emph{внешнее время}, и {\color{red}на результаты влияют различные факторы, такие как нагруженность компьютера}.

Если вы хотите получить время обработки, а не внешнее время, используйте \texttt{time.process\_time()} \cite[\strbook{574}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps

def timethis(func):
    @wraps(func)
    def wrapper(*args, **kwrags):
        start = time.process_time()  # <- NB
        r = func(*args, **kwargs)
        stop = time.process_time()  # <- NB
        print(f"{func.__module__}.{func.__name__} : {end - start}")
        return r
    return wrapper
    
@timethis
def countdown(n):
    while n > 0:
        n -= 1

countdown(100000)
\end{lstlisting}

Чтобы подсчитать время выполнения блока инструкций, можно определить менеджер контекста
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from contexlib import contexmanager

@contextmanager
def timeblock(label):
    start = time.process_time()
    try:
       yield
    finally:
        end = time.process_time()
        print(f"{label} : {end - start}")
        
with timeblock("counting"):
	n = 100000
	while n > 0:
	    n -= 1
	# counting: 1.55555
\end{lstlisting}

\section{Итераторы и генераторы}

В большинстве случаев для прохода по итериуемому объекту используется цикл \texttt{for}. Однако иногда задачи требуют более точного контроля лежащего в основе механизма итераций. 

Следующий код иллюстрирует базовые механизмы того, что происходит во время итерирования
\begin{lstlisting}[
style = ironpython,
numbers = none
]
items = [1, 2, 3] # Итерируемый объект
# Получаем объект итератора
# Функция iter(items) вызывает метод итерируемого объекта items.__iter__()
it = iter(items) # Итератор
# Запускаем итератор
next(it) # Вызывается it.__next__() -> 1
next(it) # -> 2
next(it) # -> 3
next(it) # Возбуждается исключение StopIteration
\end{lstlisting}

Список \texttt{items} как \emph{итерируемый объект} имеет метод \verb|__iter__()|, который должен возвращать \emph{объект-итератора} (\texttt{it}). У объекта-итератора должен быть метод \verb|__next__()| для перебора элементов. Вот функция \texttt{next(it)} и вызывает метод \verb|__next__()| объекта-итератора для получения следующего элемента. Когда список исчерпывается, возбуждается исключение \texttt{StopIteration}.

\emph{Протокол итераций} Python требует, чтобы метод \verb|__iter__()| возвращал специальный объект-итератор, в котором реализован метод \verb|__next__()|, который выполняет итерацию \cite[\strbook{128}]{beazley:python_cookbook-2019}. Функция \texttt{iter()} просто вовзвращает внутренний итератор, вызывая \verb|s.__iter__()|.

\emph{Протокол итератора} Python требует \verb|__iter__()|, чтобы вернуть специальный \emph{объект итератора}, в котором реализован метод \verb|__next__()|, а исключение \texttt{StopIteration} используется для подачи сигнала о завершении \cite[\strbook{131}]{beazley:python_cookbook-2019}.

Когда поток управления покидает тело генераторной функции, возбуждается исключение \texttt{StopIteration}.

Метод \verb|__iter__()| \emph{итерируемого объекта} может быть реализован как обычная \emph{генераторная функция} \cite[\strbook{133}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class linehistory:
    ...
    def __iter__(self):
        for lineno, line in enumerate(self.lines, 1):
            self.history.append((lineno, line))
            yield line
\end{lstlisting}

Для того чтобы пропустить первые несколько элементов по какому-то условию, можно воспользоваться функцией \texttt{itertools.dropwhile}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from itertools import dropwhile

def read_wo_header(file_name: str):
    with open(file_name, mode="r") as f:
        for line in dropwhile(lambda line: line.startswith("#"), f):
            print(line.rstrip())
\end{lstlisting}

Возвращаемый итератор отбрасывает первые элементы в последовательности до тех пор, пока предоставленная функция возвращает \texttt{True}.

\section{Захват переменных в анонимных функциях}

Рассмотрим поведение следующей программы:
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> x = 10
>>> a = lambda y: x + y
>>> x = 20
>>> b = lambda y: x + y
>>> a(10)  # 30
>>> b(10)  # 30
\end{lstlisting}

Проблема в том, что значение \texttt{x}, используемые lambda-выражением, является \emph{свободной переменной}, которая связывается во время \emph{выполнения}, а не во время \emph{определения} \cite[\strbook{233}]{beazley:python_cookbook-2019}. Так что значение \texttt{x} будет таким, каким ему случиться быть во время выполнения.

\remark{
\emph{Свободные переменные} связываются во время \emph{выполнения}, а не во время определения
}

Другими словами у замыканий позднее связывание. Замыкания -- это функции с расширенной областью видимости, которая включает все неглобальные переменные. То есть замыкания умеют запоминать привязки свободных переменных.

Например,
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
funcs = [
    lambda x: x + n
    for n in range(3)
]
for f in funcs:
    print(f(0))
# 2
# 2
# 2
\end{lstlisting}

\section{Передача дополнительного состояния с функциями обратного вызова}

\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import typing as t

def apply_async(
    func: t.Callable,
    args: t.Tuple[t.Union[str, int],
    *,
    callback: t.Callable]
) -> t.NoReturn:
    result: t.Union[str, int] = func(*args)
    callback(result)
    
def add(x: int, y: int) -> int:
    return x + y
\end{lstlisting}

Для хранения состояния можно использовать \emph{замыкание} \cite[\strbook{238}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def make_handler():
    count = 0
    def handler(result: t.Union[str, int]) -> t.NoReturn:
        nonlocal count
        count += 1
        print(f"[{count}] Got: {result}")
    return handler
    
handler = make_handler()
apply_async(add, (2, 3), callback=handler)  # [1] Got: 5
apply_async(add, ("hello", "world"), callback=handler)  # [2] Got: hello world 
\end{lstlisting}

\section{Использование лениво вычисляемых свойств}

Вы хотите определить доступный только для чтения атрибут как свойство, которое вычисляется при доступе к нему. Однако после того, как доступ произойдет, значение должно кешироваться и не пересчитываться при следующих запросах.

Дескпритор -- класс, который реализует три ключевые операции доступа к атрибутам (получения, присваивания и удаления) в форме специальных методов \verb|__get__()|, \verb|__set__()| и \verb|__delete__()|.

Эффективный путь определинея ленивых атрибутов -- это использование \emph{класса-дескриптора} \cite[\strbook{271}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# дескрипторный класс
class lazyproperty:
    def __init__(self, f: t.Callable):
        self.f = f
        
    def __get__(self, instance, cls):
        if instance is None:
            # Если дескриптор вызывать через объект управляющего класса,
            # например как Circle.area, то instance=None и будет возвращена
            # ссылка на объект экземпляра дескриптора
            return self  
        else:
            value = self.f(instance)
            setattr(instance, self.f.__name__, value)
            return value
\end{lstlisting}

Чтобы использовать этот код, вы можете применить его в классе
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Circle:
    def __init__(self, radius: float):
        self.radius = radius
        
    @lazyproperty
    def area(self):
        print("Computing area")
        return math.pi * self.radius ** 2
    
    @lazyproperty
    def perimeter(self):
        print("Computing perimeter")
        return 2 * math.pi * self.radius
\end{lstlisting}

Вот пример использования
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> c = Circle(radius=4.0)
>>> c.area
# Computing area
# 50.26...
>>> c.area  # 50.26...
\end{lstlisting}

Во многих случаях цель применения лениво вычисляемых атрибутов заключается в увеличении производительности. Например, вы можете избежать вычисления значений, если только они действительно где-то не нужны.

Когда дескриптор помещается в определение класса, его методы \verb|__get__()|, \verb|__set__()| и \verb|__delete__()| задействуются при доступе к атрибуту. Но если дескриптор определяет только метод \verb|__get__()|, то у него намного более слабое связывание, нежели обычно. В частности, метод \verb|__get__()| срабатывает, \emph{только если атрибут}, к которому осуществляется доступ, \emph{отсутствует в словаре экзмпляра} управляющего класса (в данном случае класса \texttt{Circle}) \cite[\strbook{272}]{beazley:python_cookbook-2019}.

Класс \texttt{lazyproperty} использует это так: он заставляет метод \verb|__get__()| сохранять вычисленное значение в экземпляре, используя то же имя, что и само свойство. С помощью этого значение сохраняется в словаре экземпляра и \underline{отключает будущие вычисления свойства}.

Возможный недостаток этого рецепта в том, что вычисленное значение становится изменяемым после создания. То есть значение, например, свойства \texttt{area} можн затереть.

Если это проблема, вы можете использовать немного менее эффективное решение \cite[\strbook{273}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def lazyproperty(func):
    name = "_lazy_" + func.__name__
    @property
    def lazy(self):
        if hasattr(self, name):
            return getattr(self, name)
        else:
            value = func(self)
            setattr(self, name, value)
            return value
    return lazy
\end{lstlisting}

В этом случае операции присваивания недоступны
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> c = Circle(4.0)
>>> c.area
Computing area
50.26...
>>> c.area
50.26...
>>> c.area = 25  # Поднимется исключение AttributeError
\end{lstlisting}

В этом случае все операции получения значения проводятся через функцию-геттер свойства. Это менее эффективно, чем простой поиск значения в словаре экземпляра.

Еще можно просто задекорировать свойство декоратором \texttt{lru\_cache}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import lru_cache

class Circle:
    def __init__(self, radius: float):
        self.radius = radius
        
    @property
    @lru_cacha
    def area(self):
        print("Computing area")
        return math.pi * self.radius ** 2
        
    @property
    @lru_cache
    def perimeter(self):
        print("Computing perimeter")
        return 2 * math.pi * self.radius
        
        
>>> circle = Circle(4.0)
>>> circle.area
# Computing area
# 50.26...
>>> circle.area  # 50.26...
\end{lstlisting}


\section{Определение более одного конструктора в классе}

Вы пишите класс и хотите, чтобы пользователи могли создавать экземпляры не только лишь единственным способом, предоставленным \verb|__init__()|.

Чтобы определить класс с более чем одним конструктором, вы должны использовать метод класса
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Circle:
    def __init__(self, radius: float, color: str = "black"):
         """
         Первичный конструктор
         """
         self.radius = radius
         self.color = color
    
    @classmethod
    def make_default_circle(cls):
        """
        Альтернативный конструктор. Конструктор тривиального класса
        """
        return cls(radius=1.0, color="red")
    
    @property
    @lru_cache
    def area(self):
        print("Computing area")
        return math.pi * self.radius ** 2
    
    @property
    @lru_cache
    def perimeter(self):
        print("Computing perimeter")
        return 2 *  math.pi * self.radius
    
    def __repr__(self):
        return f"{type(self).__name__}(radius={self.radius}, color={self.color})"
    
    def get_params(self) -> dict:
        return {"raidus": self.radius, "color": self.color}
\end{lstlisting}

Одно из главных применений \emph{методов класса} -- это определение \emph{альтренативных конструкторов} \cite[\strbook{294}]{beazley:python_cookbook-2019}. 

При определении класса с множественными конструкторами необходимо делать функцию \verb|__init__()| максимально простой -- она должна просто присваивать атрибутам значения. А вот уже альтернативные конструкторы будут вызываться при необходимости выполнения продвинутых операций.

Если требуется вызывать методы по имени, то можно воспользоваться \texttt{operator.methodcaller()}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import operator

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
        
    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

p = Point(2, 3)
operator.methodcaller("distance", 0, 0)(p)
\end{lstlisting}

Функция \texttt{methodcaller()} может быть полезна, например, в следующем случае
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Person:
    def __init__(self, name: str, job: str):
        self.name = name
        self.job = job
        
    def action_1(self):
        return "Action-1"
        
    def action_2(self):
        return "Action-2"
        
    def action_N(self):
        return "Action-N"
\end{lstlisting}

Вызвать действие теперь можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def make(*, obj, action: str):
    if hasattr(obj, action):
        return methodcaller(action)(obj)
    else:
        raise ValueError(f"Object '{type(obj).__name__}' has't action '{action}' ...")
        
leor = Person(name="Leor", job="ML")   
make(obj=leor, action="action_1")  # Action-1
make(obj=leor, action="action_2")  # Action-2
make(obj=leor, actin="action_10")  # ValueError
\end{lstlisting}

Без \texttt{methodcaller()} пришлось бы писать что-то вроде
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def bad_make(*, obj, action: str):
    if action == "action_1":
        obj.action_1()
    elif action == "action_2":
        obj.action_2()
    ...
\end{lstlisting}

\section{Параметрические декораторы}

Требуется создать функцию-декторатор, которая принимала бы аргументы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps
import logging

# level, name и message -- это параметры декоратора
def logged(level, name=None, message=None):
    # это обычный декоратор, аргумент func которого ссылается на декорируемую функцию
    def decorate(func: t.Callable):
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__
        
        @wraps(func)
        # args и kwargs -- это аргументы задекорированной функции
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)
        return wrapper
    return decorate
    
# Пример использования
@logged(logging.DEBUG)  # -> @decorate: add = deocrate(add) -> wrapper || add -> wrapper
def add(x, y):
    return x + y
    
@logged(logging.CRITICAL, "example")
def spam():
    print("Spam!")
\end{lstlisting}

Можно считать, что после объявления функции \texttt{add} вместо выражения \verb|@logged(logging.DEBUG)| стоит \verb|@decorate|, но при этом еще доступна переменная \verb|level| со значением \verb|@logging.DEBUG|, а также переменные \texttt{name} и \texttt{message} со значением \texttt{None}. Аргумент функции \texttt{decorate} получает ссылку на декорируемую функцию \texttt{add}. Затем локальные переменные \texttt{logname}, \texttt{log} и \texttt{logmsg} получают значения, после чего возвращается ссылка на вложенную функцию \texttt{wrapper}. Таким образом, при вызове функции \texttt{add} будет вызываться функция \texttt{wrapper}.

\section{Определение декоратора, принимающего необязательный аргумент}

Вы хотели бы написать один декоратор, который можно было бы использовать и без аргументов -- \verb|@decorator|, и с необязательными аргументами \verb|@decorator(x, y, z)| \cite[\strbook{339}]{beazley:python_cookbook-2019}.

\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps, partial
import logging

def logged(func=None, *, level=logging.DEBUG, name=None, message=None):
    if func is None:
        return partial(logged, level=level, name=name, message=message)
        
    logname = name if name else func.__module__
    log = logging.getLogger(logname)
    logmsg = message if message else func.__name__
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        log.log(level, logmsg)
        return func(*args, **kwargs)
    return wrapper
    
# Пример использования
@logged
def add(x, y):
    return x + y
    
@logged(level=logging.CRITICAL, name="example")
def spam():
    print("Spam")
\end{lstlisting}

Этот рецепт просто заставляет декоратор одинаково работать и с дополнительными скобками, и без.

Чтобы понять принцип работы кода, вы должны четко понимать то, как декораторы применяются к фукнциям, а также условия их вызова. Для простого декоратора, такого как этот
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@logged  # logged(func=add, ...)
def add(x, y):
    return x + y
\end{lstlisting}
последовательность вызова будет такой
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def add(x, y):
    return x + y
    
add = logged(add)
\end{lstlisting}

В этом случае обертываемая функция просто передается в \texttt{logged} первым аргументом. Поэтому в решении первый аргумент \texttt{logged()} -- это обертываемая функция. Все остальные аргументы должны иметь значения по умолчанию.

Для декоратора, принимающего аргументы, такого как этот
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@logged(level=logging.CRITICAL, name="example")  # logged(func=None, ...)
def spam():
    print("Spam")
\end{lstlisting}
последовательность вызова будет такой
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def spam():
    print("Spam")

spam = logged(level=logging.CRITICAL, name="example")(spam)
\end{lstlisting}

При первичном вызове \verb|logged()| обертываемая функция не передается. Так что в декораторе она должна быть необязательной. Это, в свою очередь, заставляет другие аргументы быть именованными. Более того, когда аргументы переданы, декоратор должен вернуть функцию, которая принимает функцию и оборачивает ее. Чтобы сделать это, в решении используется хитрый трюк с \texttt{functools.partial}. Если точнее, он просто возвращает частично примененную версию себя, где все аргументы зафиксированы, за исключением обертываемой функции.

Таким образом, при повторном вызове функции \texttt{logged} через \texttt{partial} вызов будет выглядеть следующим образом
\begin{lstlisting}[
style = ironpython,
numbers = none
]
spam = logged(func=spam, level=logging.CRITICAL, name="example", message=None)
\end{lstlisting}

Одна из особенностей декораторов в том, что они \underline{применяются только один раз}, во время \emph{определения} функции \cite[\strbook{342}]{beazley:python_cookbook-2019}

\section{Параллельное программирование}

Библиотека \texttt{concurent.futures} предоставляет класс \texttt{ProcessPoolExecutor}, который может быть использован для выполнения тяжелых вычислительных задач в \emph{отдельно запущенных экземплярах интерпретатора Python} \cite[\strbook{498}]{beazley:python_cookbook-2019}.

<<Под капотом>> \texttt{ProcessPoolExecutor} создает $ N $ независимо работающих интерпретаторов Python, где $ N $ -- это количество доступных обнаруженных в системе CPU. Пул работает до тех пор, пока не будет выполнена последняя инструкция в блоке \texttt{with}, после чего пул процессов завершается. Однако программа будет ждать, пока вся отправленная работа не будет сделана.

Чтобы получить результат от экземпляра Future, нужно вызвать метод \texttt{result()}. Это вызовет \emph{блокировку} на время, пока результат не посчитается и не будет возвращен пулом.

Несколько вопросов, связанных с пулами процессов:
\begin{itemize}
	\item Этот прием распараллеливания работает только для задач, которые легко раскладываются на независимые части,
	
	\item Работа должна отправляться в форме простых функций,
	
	\item Аргументы функций и возвращаемые значения должны быть совместимы с pickle. Работа выполняется в отдельном интерпретаторе при использовании межпроцессной коммуникации. Так что данные, которыми обмениваются интерпретаторы, должны \emph{сериализоваться},
	
	\item Пулы процессов в Unix создаются с помощью системного вызова \texttt{fork()}. Он создает клон интерпретатора Python, включая все состояние программы на момент копирования. В Windows запускается независимая копия интерпретатора, которая не клонирует состояние,
	
	\item Нужно с великой осторожностью объединять пулы процессов с программами, которые используют потоки.
\end{itemize}

\subsection{Процессы, потоки и GIL в Python}

Выдержка из книги Л. Рамальо \cite[\strbook{650}]{ramalho:python-2022}:
\begin{itemize}
	\item Каждый \emph{экземпляр интрепретатора Python} является \emph{процессом}. Дополнительные процессы Python можно запускать с помощью библиотек \texttt{multiprocessing} или \texttt{concurrent.futures}. 
	
	\item Интерпретатор Python использует единственный поток, в котором выполняется и пользовательская программа, и сборщик мусора. Для запуска дополнительных потоков предназначены библиотеки \texttt{threading} и \texttt{concurrent.futures}.
	
	\item Только один поток может выполнять Python-код, и от числа процессорных ядер это не зависит.
	
	\item Любая стандартная библиотечная функция Python, делающая системный вызов, освобождает GIL. Сюда относятся все функции, выполняющие дисковый ввод-вывод, сетеовой ввод-вывод, а также \texttt{time.sleep()}. Многие счетные функции в библиотеках numpy/scipy, а также функции сжатия и распаковки из модулей \texttt{zlib} и \texttt{bz2} также освобождают GIL.
	
	\item Влияние GIL на сетевое программирование с помощью потоков Python сравнительно невелико, потому что функции ввода-вывода освобождают GIL, а чтение или запись в сеть всегда подразумевает высокую задержку по сравнению с чтением-записью в память. Следовательно, каждый отдельный поток все равно тратит много времени на ожидание, так что их выполнение можно чередовать без заметного снижения общей пропускной способности.
	
	\item Состязание за GIL замедляет работу счетных потоков в Python. В таких случаях последовательный однопоточный код проще и быстрее.
	
	\item Для выполнения счетного Python-кода на нескольких ядрах нужно использовать несколько процессов Python.
\end{itemize}

Деталь реализации CPython. В CPython, из-за глобальной блокировки интерпретатора, в каждый момент времени Python-код может выполняться только одним потоком (хотя некоторые высокопроизводительные библиотеки умеют обходить это ограничение). Если вы хотите, чтобы приложение более эффективно использовало вычислительные ресурсы многоядерных машин, то пользуйтесь модулем \texttt{multiprocessing} или классом \texttt{concurrent.futures.ProcessPoolExecutor}. Однако многопоточное выполнение все же является вполнен пригодной моделью, если требуется одновременно выполнять несколько задач с большим объемом ввода-вывода \cite[\strbook{652}]{ramalho:python-2022}.

По умолчанию \emph{сопрограммы} вместе с \emph{управляющим циклом событий}, который предоставляется каркасом асинхронного программирования, работают в \emph{одном потоке}, поэтому GIL не оказывает на них никакого влияния. Можно использовать несколько потоков в асинхронной программе, но рекомендуется, чтобы и цикл событий, и все сопрограммы исполнялись в одном потоке, а дополнительные потоки выделялись для специальных задач.



\subsection{Глобальная блокировка интерпретатора}

Интерпретатор защищен так называемой глобальной блокировкой интерпретатора (GIL), которая позволяет \emph{только одному потоку} Python выполняться в любой конкретный момент времени \cite[\strbook{503}]{beazley:python_cookbook-2019}.

Наиболее заметный эффект GIL в том, что многопоточные программы Python не могут полностью воспользоваться преимуществами многоядерных процессоров (тяжелые вычислительные задачи, использующие больше одного потока, работают только на одном ядре процессора) \cite[\strbook{503}]{beazley:python_cookbook-2019}.

{\color{blue}GIL влияет только на программы, сильно нагружающие CPU} (то есть те, в которых вычисления доминируют). Если ваша программа в основном занимается вводом-выводом, что типично для сетевых коммуникаций, потоки часто являются разумным выбором, потому что они проводят большую часть времени в ожидании.


\section{Приемы работы с библиотекой Pandas}

\subsection{Советы по оптимизации вычислений}

В ситуации, когда необходимо итерирование, более быстрым способом итерирования строк будет использование метода \texttt{.iterrows()}. Метод \texttt{.iterrows()} оптимизирован для работы с кадрами данных, и хотя это наименее эффективный способ большинства страндартных функций, он дает значительное улучшение, по сравнению с базовым итерированием \cite[\strbook{328}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
haversine_series = []
for index, row in df.iterrows():
    haversine_series.append(haversine(...))
df["distance"] = haversin_series
\end{lstlisting}

Более эффктивным способом является использование метода \texttt{.apply()}, который применяет функцию вдоль определеной оси (вдоль строк или вдоль столбцов) кадра данных. Хотя метод \texttt{.apply()} также по своей сути перебирает строки, он делает это намного эффективнее, чем метод \texttt{.iterrows()}, используя ряд внутренних оптимизаций, например, применяя итераторы, написанные на Cython \cite[\strbook{328}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["distance"] = df.apply(lambda row: haversine(..., ..., row["latitude"], row["longitude"]), axis=1)
\end{lstlisting}

Но гораздо эффективнее задействовать векторизацию и передать не скаляры, а столбцы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["distance"] = haversine(..., ..., df["latitude"], df["longitude"])
\end{lstlisting}

Если скорость имеет наивысший приоритет, можно вместо серий использовать numpy-массивы. Как и pandas, numpy работает с массивами. однако она освобождена от дополнительных вычислительных затрат, связанных с операциями в pandas, такими как индексирование, проверка типов данных и т.д. В результате операции над массивами numpy могут выполняться значительно быстрее, чем операции над объектами \texttt{Series}.

Массивы numpy можно использовать вместо объектов \texttt{Series}, когда дополнительная функциональность, предлагаемая объектами \texttt{Series}, не является критичной. Например, векторизованная реализация функции \texttt{haversine} фактически не использует индексы в сериях \texttt{langitude} и \texttt{latitude}, и поэтому отсутствие этих индексов не приведет к нарушению работы функции
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["distance"] = haversine(..., ..., df["latitude"].values, df["longitude"].values)
\end{lstlisting}


\subsection{Рецепты}

Посмотреть какие строки значений (а не индексы) кадра данных попали в ассоциированные группы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").apply(lambda group: group["col_name"])
"""
   color  col_name
0   blue  73.0
1  green  52.0
2  green   NaN
3  green  77.0
4   blue   NaN
5  green  86.0
6    red  73.0
7    red   NaN
8  green  77.0
9    red  81.0
"""

# вывести индексы строк, по соответсвующим группам можно с помощью атрибута groups
df.groupby("color").groups
# {'blue': [0, 4], 'green': [1, 2, 3, 5, 8], 'red': [6, 7, 9]}
\end{lstlisting}

Заполнить пропущенные значения средним на сгруппированном по некоторому полю кадре данных
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").apply(
    lambda group: group.fillna(group["col_name"].mean())
)
\end{lstlisting}

При проведении разведочного анализа данных лучше всего сначала загрузить данные и исследовать их с помощью запросов/логического отбора. Затем создайте индекс, если ваши данные поддерживают его или если вам требуется повышенная производительность \cite[\strbook{115}]{heydt:pandas-2019}. Операции поиска с использованием индекса обычно выполняются быстрее. В силу лучшей производительности выполнение поиска по индексу (в тех случаях, когда это возможно) обычно является оптимальным решением. Недостаток использования индекса заключается в том, что потребуется время на его создание, кроме того, он занимает больше памяти.

Выполнить слияние кадров данных можно с помощью функции \texttt{pd.merge} или метода \texttt{.merge}. По умолчанию слияние выполняется по \emph{общим меткам столбцов}, однако сливать кадры данных можно и \emph{по строкам с общими индексами} \cite[\strbook{230}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Слияние по строкам
# Нужно задать оба параметра!
left.merge(right, left_index=True, right_index=True)
\end{lstlisting}

Кроме того, библиотека pandas предлагает метод \texttt{.join()}, который можно использовать для выполнения соединения с помощью \emph{индексных меток} двух объектов \texttt{DataFrame} (вместо значений столбцов) \cite[\strbook{232}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Слияние по строкам
# Здесь предполагается, что кадры данных имеют
# дублирующиеся имена столбцов, поэтому мы задаем lsuffix и rsuffix
left.join(right, lsuffix="_left", rsuffix="_right")
\end{lstlisting}

\remark{
Метод \texttt{.join()} по умолчанию используется \emph{внешнее соединение}, в отличие от метода \texttt{.merge()}, в котором по умолчанию применяется \emph{внутренее соединение}.
}

\emph{Состыковка} (stack) помещает уровень индекса столбцов в новый уровень индекса строк
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df = pd.DataFrame({
    "a": [1, 2],
    "b": [100, 200]
})
"""
     a    b
one  1  100
two  2  200
"""
df.stack()
"""
one  a      1
	   b    100
two  a      2
 	   b    200
"""
df.loc[("one", "b")]  # 100
\end{lstlisting}

Состыковку удобно применять к результатам аггрегации на группах
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
df.groupby("color")[["key1", "key4"]].agg([np.mean, np.std])
"""
           key1            key4
           mean       std  mean        std
color
blue   0.904027  0.508690  73.5  21.920310
green -0.493756  1.025554  65.0   9.899495
red   -0.399363       NaN  55.0        NaN
"""
# Состыковка
res = df.groupby("color")[["key1", "key4"]].agg([np.mean, np.std]).stack()
"""
                key1       key4
color
blue  mean  0.904027  73.500000
      std   0.508690  21.920310
green mean -0.493756  65.000000
      std   1.025554   9.899495
red   mean -0.399363  55.000000
"""
res.loc[("blue", "mean")]
"""
key1     0.904027
key4    73.500000
Name: (blue, mean), dtype: float64
"""
\end{lstlisting}

При построении агрегатов со сложным именем можно воспользоваться псевдонимами
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color")[["key1", "key2"]].agg([("MEAN", np.nanmean), ("STD", np.nanstd)]).stack()
"""
                key1      key2
color
blue  MEAN  0.544329  0.731969
green MEAN  0.231420  1.272040
       STD        NaN  1.255945
red   MEAN -0.399363  0.483054
"""
\end{lstlisting}

\emph{Расстыковка} (unstack) помещает самый внутренний уровень индекса строк в новый уровень индекса столбцов.

\emph{Расплавление} -- это тип организации данных, который часто называют преобразованием объекта DataFrame из <<широкого>> формата в <<длинный>> формат.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
data = pd.DataFrame({
    "Name": ["Mike", "Mikal"],
    "Height": [6.1, 6.0],
    "Weight": [220, 185],
})
data
"""
     Name  Heigth  Weight
0    Mike     6.1     220
1  Mikael     6.0     185
"""
\end{lstlisting}

Расплавляем кадр данных
\begin{lstlisting}[
style = ironpython,
numbers = none
]
pd.melt(
    data,
    id_vars=["Name"],
    value_vars=["Height", "Weight"]
)
"""
     Name variable  value
0    Mike   Heigth    6.1
1  Mikael   Heigth    6.0
2    Mike   Weight  220.0
3  Mikael   Weight  185.0
"""
\end{lstlisting}

Получить данные по группе
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").get_group("blue")
\end{lstlisting}

Отфильтровать группы по условию. Если функция возвращает \texttt{True}, то группа включается в результат
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").filter(lambda group: group.col_name.count() > 1)
\end{lstlisting}



% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{beazley:python-2010}{\emph{Бизли Д.} Python. Подробный справочник. -- СПб.: Символ-Плюс, 2010. -- 864 с.}
	
	\bibitem{beazley:python_cookbook-2019}{\emph{Бизли Д.} Python. Книга рецептов. -- М.: ДМК Пресс., 2019. -- 648 с.}
	
	\bibitem{ramalho:python-2022}{\emph{Рамальо Л.} Python -- к вершинам мастерства: Лаконичное и эффективное программирование. -- М.: МК Пресс, 2022. -- 898 с.}
	
	\bibitem{heydt:pandas-2019}{\emph{Хейдт М., Груздев А.} Изучаем pandas. -- М.: ДМК Пресс, 2019. -- 682 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

%\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
