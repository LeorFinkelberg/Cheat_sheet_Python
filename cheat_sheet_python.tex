\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Некоторые вопросы программирования на языке Python}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Терминология}

Любой элемент данных, используемый в программе на Python, является \emph{объектом} \cite[\strbook{57}]{beazley:python-2010}.

Каждый объект имеет свою:
\begin{itemize}
	\item идентичность,
	
	\item тип (или класс),
	
	\item значение.
\end{itemize}

Например, когда в программе встречается интсрукция \verb|a = 42|, интерпретатор создает целочисленный объект со значением 42. Можно рассматривать идентичность объекта как указатель на область памяти, где находится объект, а индентификатор \texttt{a} -- как имя, которое ссылается на эту область памяти.

\emph{Тип объекта} сам по себе является \emph{объектом}, который называется \emph{классом объекта}. Все объекты в яызке Python могут быть отнесены к \emph{объектам первого класса} \cite[\strbook{61}]{beazley:python-2010}. Это означает, что все объекты, имеющие идентификатор, можно интерпретировать как \emph{данные}.

Тип \texttt{None} используется для представления пустых объектов (т.е. объектов, не имеющих значений). Этот объект возвращается функциями, которые не имеют явно возвращаемого значения. Объект \texttt{None} часто используется как значение по умолчанию для необязательных аргументов. Объкт \texttt{None} не имеет атрибутов и в логическом контексте оценивается как значение \texttt{False}.

Функции, классы и модули в языке Python являются объектами, которыми можно манипулировать как обычными данными.

\emph{Свободные переменные} -- переменные, которые были определены в объемлющих функциях, а используются вложенными функциями \cite[\strbook{81}]{beazley:python-2010}.

Все функциональные возможности языка, включая присваивание значений переменным, определение функций и классов, импортирование модулей, реализованы в виде инструкций, обладающих равным положением со всеми остальными инструкциями.

\section{Передача параметров и возвращаемые значения}

Параметры функции, которые передаются ей при вызове, являются \emph{обычными именами}, ссылающимися на \emph{входные объекты}. Семантика передачи параметров в языке Python не имеет точного соответствия какому-либо одному способу, такому как <<передача по значению>> или <<передача по ссылке>>. Например, если функции передается неизменяемое значение, это выглядит, как передача аргумента по значению. Однако при передачи изменяемого объекта (такого как список или словарь), который модифицируется функцией, эти изменения будут отражаться на исходном объекте \cite[\strbook{133}]{beazley:python-2010}.

\section{Правила видимости в функциях}

При каждом вызове функции создается новое локальное пространство имен. Это пространство имен представляет локальное окружение, содержащее имена параметров функции, а также имена переменных, которым были присвоины значения в теле функции. Когда возникает необходимость отыскать имя, интерпретатор в первую очередь просматривает локальное пространство имен. Если искомое имя не было найдено, поиск продолжается в глобальном пространстве имен. Глобальным пространством имен для функций всегда является пространство имен модуля, в котором эта функция была определена. Если интерпретатор не найдет искомое имя в глобальном пространстве имен, поиск будет продолжен во встроенном пространстве имен. Если и эта попытка окажется неудачной, будет возбуждено исключение \texttt{NameError}.

В языке Python поддерживается возможность определять вложенные функции. Переменные во вложенных функциях привязаны к лексической области видимости. То есть поиск имени переменной начинается в \emph{локальной области видимости} и затем последовательно продолжается во всех \emph{объемлющих областях видимости} внешних функций, в направлении от внутренних к внешним. Если и в этих пространствах имен искомое имя не будет найдено, поиск будет продолжен в \emph{глобальном}, а затем во \emph{встроенном пространстве имен}, как и прежде.

При обращении к локальной переменной до того, как ей будет присвоено значение, возбуждается исключение \texttt{UnboundLocalError}
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
i = 0

def foo():
    i = i + 1
    print(i)  # UnboundLocalError
\end{lstlisting}

В функции \texttt{foo} переменная \texttt{i} определяется как локальная переменная, потому что внутри функции ей присваивается некоторое значение и отсутствует инструкция \texttt{global}). При этом инструкция присваивания \texttt{i = i + 1} пытается прочитать значение переменной \texttt{i} еще до того, как ей будет присвоено значение. 

Хотя в этом примере существует глобальная переменная \texttt{i}, она не используется для получения значения. Переменные в функциях могут быть \emph{либо локальными}, \emph{либо глобальными} и не могут произвольно изменять область видимости в середине функции. Например, нельзя считать, что переменная \texttt{i} в выражении \texttt{i = i + 1} в предыдущем фрагменте обращается к глобальной переменной \texttt{i}; при этом переменная \texttt{i} в вызове \texttt{print(i)} подразумевает локальную переменную \texttt{i}, созданную в предыдущей инструкции \cite[\strbook{136}]{beazley:python-2010}.

\section{Функции как объекты и замыкания}

\emph{Функции} в языке Python -- \emph{объекты первого класса}. Это означает, что они могут передаваться другим функциям в виде аргументов, сохраняться в структурах данных и возвращаеться функциями в виде результата.

Когда инструкции, составляющие функцию, упаковываются вместе с окружением, в котором они выполняются, получившийся объект называют \emph{замыканием}. Такое поведение объясняется наличием у каждой функции атрибута \verb|__globals__|, ссылающегося на глобальное пространство имен, в котором функция была определена. Это пространство имен всегда соответсвтует модулю, в котором функция была объявлена \cite[\strbook{137}]{beazley:python-2010}.

Когда функция используется как вложенная, в замыкание включается все ее окружение, необходимое для работы внутренней функции.

\emph{Глобальным пространством имен} для функции всегда будет \emph{модуль}, в котором она была \underline{объявлена}, а не пространство имен, в которое эта функция была импортирована и откуда была вызвана \cite[\strbook{192}]{beazley:python-2010}.





% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{koltzov-c-lang:2019}{ \emph{Кольцов Д.М.} Си на примерах. Практика, практика и только практика. -- СПб.: Наука и Техника, 2019. -- 288 с.}
	\bibitem{beazley:python-2010}{\emph{Бизли Д.} Python. Подробный справочник. -- СПб.: Символ-Плюс, 2010. -- 864 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
