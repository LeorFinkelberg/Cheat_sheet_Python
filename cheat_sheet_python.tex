\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Некоторые вопросы программирования на языке Python и приемы работы со специализированными библиотеками}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Терминология}

Любой элемент данных, используемый в программе на Python, является \emph{объектом} \cite[\strbook{57}]{beazley:python-2010}.

Каждый объект имеет свою:
\begin{itemize}
	\item идентичность,
	
	\item тип (или класс),
	
	\item значение.
\end{itemize}

Например, когда в программе встречается интсрукция \verb|a = 42|, интерпретатор создает целочисленный объект со значением 42. Можно рассматривать идентичность объекта как указатель на область памяти, где находится объект, а индентификатор \texttt{a} -- как имя, которое ссылается на эту область памяти.

\emph{Тип объекта} сам по себе является \emph{объектом}, который называется \emph{классом объекта}. Все объекты в яызке Python могут быть отнесены к \emph{объектам первого класса} \cite[\strbook{61}]{beazley:python-2010}. Это означает, что все объекты, имеющие идентификатор, можно интерпретировать как \emph{данные}.

Тип \texttt{None} используется для представления пустых объектов (т.е. объектов, не имеющих значений). Этот объект возвращается функциями, которые не имеют явно возвращаемого значения. Объект \texttt{None} часто используется как значение по умолчанию для необязательных аргументов. Объкт \texttt{None} не имеет атрибутов и в логическом контексте оценивается как значение \texttt{False}.

\emph{Функции}, \emph{классы} и \emph{модули} в языке Python являются объектами, которыми можно манипулировать как обычными данными.

\emph{Свободные переменные} -- переменные, которые были определены в объемлющих функциях, а используются вложенными функциями \cite[\strbook{81}]{beazley:python-2010}.

Все функциональные возможности языка, включая присваивание значений переменным, определение функций и классов, импортирование модулей, реализованы в виде инструкций, обладающих равным положением со всеми остальными инструкциями.

\section{Установка Python-пакетов из репозитория}

Пакет можно сразу установить из репозитория
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ python -m pip install git+https://github.com/autonlab/wasel#egg=weasel[all]
\end{lstlisting}

Или так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ git clone https://github.com/autonlab/weasel.git
$ cd weasel
$ pip install -e .[all]
\end{lstlisting}

При установке пакета в <<редактируемом>> режиме (editable mode) \url{https://pip.pypa.io/en/stable/topics/local-project-installs/#editable-installs}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ pip install -e .
\end{lstlisting}
никакие файлы не копируются. Это удобно, когда требуется, например, внести изменения в проекты с открытым исходным кодом. Устанавливаем проект в редактируемом режиме, вносим изменения, тестируем их и затем отправляем Pull Request. 

\section{Пример настройки CI в GitLab}

\begin{lstlisting}[
title = {\sffamily .gitlab-ci.yaml},
style = bash,
numbers = none
]
variables:
	LANGUAGE: "python"
	SKIP_SONARQUBE_JOB: "true"
	SKIP_PYTHON_TEST: "true"

include:
	- project: "$CI_PIPELINE_PROJECT"   
	ref: "$CI_PIPELINE_VERSION"       
	file: "$CI_PIPELINE_FILE"         

Build Python package:
	rules:
		# Ability to skip a stage
		- if: $SKIP_PYTHON_PACKAGE_BUILD =~ /^(true|yes|on|1)$/i
		when: never

	# Don't run for Dependabot commit branch
	- if: $CI_COMMIT_BRANCH =~ /^dependabot-.*$/
		when: never

	# Skip branch pipeline if MR opened for exclude duplications
	- if: >-
		$CI_COMMIT_BRANCH != null &&
		$CI_PIPELINE_SOURCE == 'push' &&
		$CI_OPEN_MERGE_REQUESTS != null
	when: never

	# Run if project is python language
	- if: >-
		$CI_COMMIT_TAG =~ /^([1-9][0-9]*!)?(0|[1-9][0-9]*)(\.(0|[1-9][0-9]*))*((a|b|rc)(0|[1-9][0-9]*))?(\.post(0|[1-9][0-9]*))?(\.dev(0|[1-9][0-9]*))?$/i
		&& (
			$LANGUAGE =~ /^(python)\b/i ||
			(
				$LANGUAGE == null &&
				$CI_PROJECT_REPOSITORY_LANGUAGES =~ /^(python)\b/i
			)
		)
	exists:
	- setup.py
\end{lstlisting}


\section{Соглашения по именованию классов, функций и переменных}

Шаблон именования функции (P)A/HC/LC
\begin{lstlisting}[
style = bash,
numbers = none
]
префикс? (P) + действие (A) + высокоуровневый контекст (HC) + низкоуровневый контекст (LC)
\end{lstlisting}

\section{Приемы работы с пакетом Nox}

\subsection{Общий шаблон}

Nox \url{https://nox.thea.codes/en/stable/index.html} -- библиотека и утилита командной строки для автоматизации различных процедур в мульти-средах Python -- от простого запуска тестов с помощью, например, \verb|pytest|, линтеров или сборщиков Docker-образов и до запуска цепочек выполнения произвольной сложности.

Если говорить о Python-сцериях, то в файле \verb|noxfile.py| описывается только процедура запуска сценария (вызов сценрия из оболочки), а не сам сценарий.

Для запуска утилиты \verb|nox| требуется подговтоить файл \verb|noxfile.py| и положить его в корень проекта
\begin{lstlisting}[
title = {\sffamily noxfile.py},
style = ironpython,
numbers = none	
]
import nox


nox.needs_version = ">=2019.5.30"
nox.options.default_venv_backend = "conda"

@nox.session(python=False)
def docker(session):
	session.run(
		"sudo", "docker", "build",
		"--build-arg", "USER_ID=1000",
		"--build-arg", "GROUP_ID=1000",
		"--build-arg", "STRATEGY_NAME=fix_bins_ints_in_relax_sol",
		"--build-arg", "PATH_TO_STRATEGIES_DIR=./data/strategies",
		"-t", "tthec-fix_bins_ints_in_relax_sol",
		"."
	)

@nox.session(
    python=["3.8", "3.9", "3.10"],  # тесты выполняются для 3-х версий Python
    venv_backend="conda",
    reuse_venv=True,
)
def test(session):
    # conda ставит только PySCIPOpt==4.3.0 с канала conda-forge
    session.conda_install("pyscipopt==4.3.0", channel="conda-forge")
    # --no-deps, чтобы не сломать окружение conda
    session.install("--no-deps", "-r", "requirements.txt")
    session.run(
        "pytest",
        "-v",
        "-k", "solver",  #запускает только те тесты, в имени которых есть подстрока 'solver'
        env = {  # здесь описываются переменные окружения
            "PYTHONPATH": "./src",  # как если бы запускали $ PYTHONPATH=./src pytest
        }
    )
\end{lstlisting}

Теперь для запуска сессии сборки образа нужно просто запустить утилиту с указанием имени сессии
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nox -s docker
\end{lstlisting}

То есть в файле \verb|noxfile.py| можно описывать любые сессии, которые автоматизируют различные задачи (запуск тестов, сборку Docker-образов и пр.) и доступ к этим сессиям будет, так сказать, с одной точки.

Можно запускать цепочки
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import nox
import pathlib2

# NOX OPTIONS
nox.needs_version = ">=2022"
nox.options.default_venv_backend = "conda"

# PROJECT PARAMS
STRATEGY_NAME = "fix_bins_ints_in_relax_sol_with_perturbation"
PROBLEM_FILE_NAME = "model_MNPZ_march_no_plecho_no_CDO_only_BRN.mps"

PATH_TO_DATA_DIR = Path().joinpath("data/").absolute()
PATH_TO_PROBLEMS_DIR = PATH_TO_DATA_DIR.joinpath("problems/")
PATH_TO_MAKE_STRATEGY_FILE = Path("./src/strategy_templates/make_strategy_file.py")
PATH_TO_SETTINGS_DIR = PATH_TO_DATA_DIR.joinpath("settings/")
PATH_TO_RELAX_SET_FILE = PATH_TO_SETTINGS_DIR.joinpath("scip_relax.set")
PATH_TO_MILP_SET_FILE = PATH_TO_SETTINGS_DIR.joinpath("scip_milp.set")
PATH_TO_STRATEGIES_DIR_HOST = PATH_TO_DATA_DIR.joinpath("strategies/")
PATH_TO_STRATEGIES_DIR_CONTAINER = "./data/strategies"

DOCKER_MEMORY = 8000  # Mb
DOCKER_MEMORY_SWAP = 8000  # Mb

DEFAULT_INTERPRETER = "3.8"
TARGET_INTERPRETERS = ("3.8", "3.9", "3.10")

# ENVS
env = {"PYTHONPATH": "./src"}

@nox.session(python=False)
def run_app_with_docker(session):
	session.run(
		"sudo", "docker", "build",
		"--build-arg", "USER_ID=1000",
		"--build-arg", "GROUP_ID=1000",
		"--build-arg", "STRATEGY_NAME=fix_bins_ints_in_relax_sol",
		"--build-arg", "PATH_TO_STRATEGIES_DIR=./data/strategies",
		"-t", "tthec-fix_bins_ints_in_relax_sol",
		"."  # контекст
	)
	# вызов следующего вспомогательного сценария
	session.notify("make_strategy_file")
	
@nox.session(python=DEFAULT_INTERPRETER)
def make_strategy_file(session):
    session.install("pathlib2>=2.3.7")
    session.run(
	    "python", PATH_TO_MAKE_STRATEGY_FILE,
	    "--strategy-name", STRATEGY_NAME,
	    "--path-to-relax-set-file", PATH_TO_RELAX_SET_FILE,
	    "--path-to-milp-set-file", PATH_TO_MILP_SET_FILE,
	    "--path-to-test-problem-file", PATH_TO_PROBLEMS_DIR.joinpath(PROBLEM_FILE_NAME),
	    "--path-to-strategies-dir", PATH_TO_STRATEGIES_DIR_HOST,
	    env=env,
    )
    # вызов следующего вспомогательного сценария
    session.notify("docker_run")
    
@nox.session(python=False)
def docker_run(session):
	session.run(
		"sudo", "docker", "run",
		"--rm",
		"-v", f"{PATH_TO_DATA_DIR}:/data",
		"-m", f"{DOCKER_MEMORY}m",
		"--memory-swap", f"{DOCKER_MEMORY_SWAP}m",
		f"tthec-{STRATEGY_NAME}"
	)
...
\end{lstlisting}

Запуск цепочки
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nox -s run_app_with_docker
\end{lstlisting}

Чтобы захватить вывод команды оболочки, нужно у метода \verb|run| выставить \verb|silent=True|
\begin{lstlisting}[
style = bash,
numbers = none
]
@nox.session(python=False)
def f(session):
	USER_ID = session.run("bash", "-c", "echo $(id -u)", silent=True)
	GROUP_ID = session.run("bash", "-c", "echo $(id -g)", silent=True)
	...
\end{lstlisting}

\subsection{Запуск тестов в мультисредах Python}

Для того чтобы запустить тесты сразу для нескольких версий интерпретатора достаточно просто передать список нужных версий декоратору \verb|@nox.session(python=["3.8", "3.9", ...])|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@nox.session(
    python=["3.8", "3.9"],
    venv_backend="conda",
    reuse_venv=False,
)
def test(session):
    session.conda_install("pyscipopt==4.3.0", channel="conda-forge")
    session.install("--no-deps", "-r", "requirements.txt")
    
    session.run(
        "pytest",
        "-v",
        env={"PYTHONPATH": "./src"}
    )
\end{lstlisting}

\subsection{Nox как утилита командной строки}

\url{https://nox.thea.codes/en/stable/usage.html}

Вывести список сессий
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nox -l
* test-3.8
* test-3.9
* test-3.10
\end{lstlisting}

Запустить только тестирование для Python 3.10
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nox --session test-3.10  # или с коротким флагом '-s'
\end{lstlisting}

После запуска сессий по умолчанию в текущей директории создается скрытая директория \verb|.nox|, в которую записывается сводка по запускам. Чтобы создать эту сводку в указанном пользователем месте, нужно использовать флаг \verb|--envdir|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nox --envdir /tmp/envs
\end{lstlisting}

Утилите \verb|nox| можно передать позиционные аргументы
\begin{lstlisting}[
style = bash,
numbers = none
]
...
@nox.session
def test(session):
    if session.posargs:
        test_files = session.posargs
    else:
        test_files = ["test_a.py", "test_b.py"]
        
   session.run("pytest", *test_files)
   
$ nox -- test_c.py
\end{lstlisting}

Еще один важный момент заключается в том, что если требуется управлять цепочкой выполнения по условию, то можно пробросить значения аргументов командной строки через аргумент \verb|posargs| функции \verb|notify|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@nox.session(python=DEFAULT_INTERPRETER)
def fake1(session):
    args: t.List[str] = session.posargs
    
    if args and ("docker" in args):
        use_docker = True
    else:
        use_docker = False
        
    session.notify("fake2", posargs=[use_docker])  # пробрасываем значение аргумента
    
@nox.session(python=DEFAULT_INTERPRETER)
def fake2(session):
    print(session.posargs)
\end{lstlisting}

Теперь можно вызвать сессию так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nox -s fake1 -- docker
\end{lstlisting}

ВАЖНО: Не обязательно пробрасывать значения аргумента через все элементы цепочки. Значение аргумента, переданное в <<головной>> элемент цепочки, можно прочитать в любом другом элементе как \verb|session.posargs|


\section{Приемы работы с pip}

С одной стороны в виртуальное окружение conda можно устанавливать пакеты с помощью менеджера \verb|pip|, но все-таки лучше с \verb|pip| использовать флаг \verb|--no-deps|. Это поможет не сломать окружение \verb|conda|. В противном случае пакеты устанавливаемые с помощью \verb|pip| могут получить несовместимые версии с пакетами уже установленными в окружении conda \url{https://nox.thea.codes/en/stable/tutorial.html}
\begin{lstlisting}[
style = bash,
numbers = none	
]
$ pip install --no-deps -r req.txt
\end{lstlisting}

\section{Приемы работы с пакетом Click}

Click поддерживает два типа параметров для сценариев: опции (options) и аргументы (arguments). В документации \url{https://click.palletsprojects.com/en/8.1.x/parameters/} говорится, что \emph{аргументы} рекомендуется использовать для перехода к подкомандам или входным файлам, URLs etc., а для всего остального -- \emph{опции}.

Аргументы умеют меньше, чем параметры. Однако по умолчанию аргументы, в отличие от опций, могут принимать произвольное количество аргументов. Опции могут принимать только заданное количество аргументов (по умолчанию 1).

По умолчанию {параметры}-опции (options), которые объявляются с помощью декоратора \verb|@click.option()|, необязательны. Чтобы сделать \emph{опциональный параметр обязательным} нужно просто передать \verb|requried=True| \url{https://click.palletsprojects.com/en/8.1.x/options/}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@click.command()
@click.option("--n", requried=True, type=int)
def dots(n):
    click.echo("-" * n)
    
if __name__ == "__main__":
    dots()
\end{lstlisting}

Пример интерфейса командной строки для пакета ZyOpt
\begin{lstlisting}[
style = ironpython,
numbers = none
]
#!python

import click
from zyopt.common.validators import ValidSolverName

@click.command(
    name="zyopt-cli",
    help="Solves MILP-problems with stochastic and ML-approches.",
)
@click.option(
    "-ptb",
    "--path-to-problem",
    type=click.Path(
        exists=True,
        file_okay=True,
        readable=True,
    )
)
@click.option(
    # понимает true/false, t/f, yes/no, on/off, 1/0
    "--use-warm-start",
    type=click.BOOL,
    default=True,
)
@click.option(
	"-svr",
	"--selected-vars-ratio",
	type=click.FloatRange(
		min=0.01,
		max=0.99,
		clamp=True,
	),
	default=0.95,
)
@click.option(
	"-snrp",
	"--solver-name-relax-phase",
	type=click.Choice(
	    tuple(elem.value for elem in ValidSolverName),
	    case_sensitive=False,
	),
	default=ValidSolverName.HIGHS.value.lower(),
	help="Solver name of RELAX-phase",
)
def main(
    path_to_problem,
    use_warm_start,
    selected_vars_ratio,
    solver_name_relax_phase,
):
    pass
    
    
if __name__ == "__main__":
    main()
\end{lstlisting}

Вызов
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./zyopt_cli.py --path-to-problem ./problem.mps --use-warm-start on ...
\end{lstlisting}

\section{Аннотация типов}

Аннотации обрабатываются интерпретатором \emph{на этапе импорта}, тогда же, когда значения по умолчанию \cite[\strbook{508}]{ramalho:python-2022}.

Расширяющееся использование аннотации типов подняло две проблемы \cite{ramalho:python-2022}:
\begin{enumerate}
	\item импорт модулей занимает больше времени и потребляет больше памяти, если используется много аннотаций,
	
	\item ссылка на еще не определенные типы требует использования строк, а не фактических типов.
\end{enumerate}

Хранение аннотации в виде строк иногда необходимо из-за проблемы <<опережающей ссылки>>: когда аннотация типа должна сослаться на класс, определенный в том же модуле ниже. Поскольку объект класса не определен, пока Python не закончит вычисление тела класса, в аннотациях типов необходимо указывать \emph{имя класса в виде строки} \cite[\strbook{508}]{ramalho:python-2022}. Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Rectangle:
	# ...
	def stretch(self, factor: float) -> "Rectangle":
		return Rectangle(width=self.width * factor)
\end{lstlisting}

Запись еще не определенных типов в виде строки в аннотациях типов -- стандартная и обязательная практика в версии Python 3.10.

В PEP 563 <<Postponed Evaluation of Annotations>> сделал необязательной запись аннотации в виде строк и уменьшил время, необходимое для обработки аннотаций типов во время выполнения. В этом PEP предлагается изменить аннотации функций и переменных, так чтобы они больше не вычислялись в момент определения функции. Вместо этого они сохраняются в аннотациях в строковой форме.

Начиная с версии Python 3.7 именно так и обрабатываются аннотации в любом модуле, который начинается следующим предложением
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from __future__ import annotaions
\end{lstlisting}

Вызов \verb|typing.get_type_hints| дает нам реальные типы -- даже в тех случаях, когда в исходной аннотации тип был записан в виде закавыченной строки. Это рекомендуемый способ читать аннотации типов во время выполнения.




\emph{Значением функции} всегда является \emph{конкретный объект}, поэтому в аннотации для \emph{возвращаемого значения} должен быть указан \emph{конкретный тип} \cite[\strbook{277}]{ramalho:python-2022}. В разделе документации, посвященном \verb*|typing.List| говорится, что обобщенная версия \verb*|list| полезна для аннотирования 
\emph{типов возвращаемых значений}, а для аннотирования \emph{аргументов} лучше использовать \emph{абстрактные} коллекции, например \verb*|Sequence| или \verb*|Iterable|.

{\color{blue}
То есть функция \emph{всегда} принимает объекты <<широких>> типов, то есть подтипов или абстрактных типов (чтобы можно было, скажем вместо \verb*|dict| передать \verb*|OrderDict| или \verb*|UserDict|), а возвращает объекты <<узких>> \underline{конкретных} типов.
}

Начиная с версии Python 3.9 большинство ABC из модуля \verb*|collections.abc| и другие конкретные классы из модуля \verb*|collections|, а также встроенные коллекции поддерживают нотацию аннтотации обобщенных классов вида \verb*|collections.deque[str]|. Соответвствуюшие коллекции из модуля \verb*|typing| нужны только для поддержки кода, написанного для версии Python 3.8 или более ранней \cite[\strbook{278}]{ramalho:python-2022}.

То есть
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collections.abc import Iterable

def f(seq: Iterable[str]) -> list[str]:
    return sorted(seq, key=len)
\end{lstlisting}

В документе PEP 613 <<Explicit Type Aliases>> введен специальный тип \verb|TypeAlias|, идея которого в том, чтобы сделать создаваемые пседонимы типов хорошо видимыми и упростить для них проверку типов
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from typing import TypeAlias

FromTo: TypeAlias = tuple[str, str]
\end{lstlisting}

Тип \verb*|Sequence| можно использовать тогда, когда по логике нужно знать длину последовательности. Как и \verb*|Sequence|, объект \verb*|Iterable| лучше использовать в качестве \emph{типа параметра}. В качестве типа возвращаемого значения он не позволяет составить представление о том, что же будет на выходе. Функция должна более ясно говорить о том, какой конкретный тип она возвращает.

Если требуется указать \emph{верхнюю границу допустимых типов} (параметр-тип может быть \verb*|Hashable| или любым его \emph{подтипом}), то можно сделать так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collections.abc import Iterable, Hashable
from typing import TypeVar

HashableT = TypeVar("T", bound=Hashable)

def mode(data: Iterable[HashableT]) -> HashableT:
    pairs = Counter(data).most_common(1)
    if len(pairs) == 0:
        raise ValueError("no mode for emtpy data")
    
    return pairs[0][0]
\end{lstlisting}

А ограничить \verb*|TypeVar| можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
NumberT = TypeVar("NumberT", float, Decimal, Fraction)
\end{lstlisting}

С помощью \verb*|Iterator| можно зааннотировать генераторное выражение, например
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collections.abc import Iterator

# генераторное выражение
series: Iterator[tuple[int, str]] = (len(s), s) for s in ...)
\end{lstlisting}

Если нужна аннотация типа для функций с \emph{гибкой сигнатурой}, нужно заменить весь список параметров многоточием \cite[\strbook{289}]{ramalho:python-2022}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
Callable[..., ReturnType]
\end{lstlisting}

Если даны тип \verb*|T1| и подтип \verb*|T2|, то \verb*|T2| \emph{совместим} с типом \verb*|T1| (подстановка Лисков) \cite[\strbook{268}]{ramalho:python-2022}.

\verb*|Annotated| можно использовать, если требуется добавить \emph{контекст для типа}, например
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from typing import Annotated  # Python 3.9 or above
from typing_extensions import Annotated  # Older than 3.9
import pandas as pd
from bentoml.validators import DataframeSchema

@bentoml.service
class IrisClassifier:
	@bentoml.api
	def classify(
		self,
		input_: Annotated[  # NB
		    pd.Dataframe,
		    DataframeSchema(orient="records", columns=["petal_length", "petal_width"])
		]
	) -> int:
		# Classification logic using the input DataFrame
		...
\end{lstlisting}


\subsection{Вариантность в типах Callable}

Пусть есть функция высшего порядка, которая принимает два вызываемых объекта
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collections.abc import Callable

def update(
    probe: Callable[[], float],  # "-" у аргумента `probe` КОНТРАвариантная позиция
    display: Callable[[float], None],  # "-" у аргумента `display` КОНТРАвариантная позиция
) -> None:  # "+" у выхода функции КОвариантная позиция
    ...
\end{lstlisting}

Чтобы сохранить правильную вариантность по отношению к аргументам функции \verb*|update| в \verb*|Callable| вариантность \emph{инвертируется}, то есть $\text{Callable[[\ ]}_+, \text{float}_{-}]$.

Например, аргументу \verb*|probe| можно вместо объекта типа \verb|Callable[[], float]| передать объект типа \verb|Callable[[], int]|, так как по отношению к \verb*|Callable| \verb*|float| стоит в контравариантной позиции (\texttt{-}) и потому допускает замену на свой \emph{подтип}.

Напротив в \verb|Callable[[float], None]| \verb*|float| стоит в ковариантной позиции (\texttt{+}) и допускает замену на свой \emph{супертип}.

В общем случае аргументы функции стоят в контравариантной поизции (\texttt{-}), так как функция ожидает объекты более общих типов (подтипов или абстрактных типов), а выход функций стоит в коваринтной позиции, чтобы можно было возвращать более конкретный тип.

\subsection{Аннотирование чисто позиционных и вариадических параметров}

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import typing as t

def tag(
    name: str,
    /,  # все что слева от слеша это чисто позиционные аргументы
    *content: str,
    class_: t.Optional[str] = None,
    **attrs: str,
) -> None:
    ...
\end{lstlisting}

Внутри функции \verb*|content| будет иметь тип \verb|tuple[str, ...]|, а \verb*|attrs| -- тип \verb|dict[str, str]|. Если бы аннотация имела вид \verb|**attrs: float|, то аргумент \verb*|attr| имел бы тип \verb|dict[str, float]|.

Для того чтобы блок проверки условий выглядел завершенным, то есть содержал ветки \verb*|if|, \verb*|elif| и \verb*|else| даже в тех случах, когда логика ветки \verb*|else| обрабатывается где-то в другом месте (например, в валидаторе), можно использовать такую функцию
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import typing as t

def assert_never(_: t.NoReturn) -> t.NoReturn:
    raise AssertationError("Error! Expected code to be unreachable")
\end{lstlisting}

Пример использования
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import enum
from typing_extensions import Never

def assert_never(arg: Never) -> Never:
	raise AssertionError("Expected code to be unreachable")

class Op(enum.Enum):
	ADD = 1
	SUBTRACT = 2

def calculate(left: int, op: Op, right: int) -> int:
	match op:
		case Op.ADD:
			return left + right
		case Op.SUBTRACT:
			return left - right
		case _:
			assert_never(op)
\end{lstlisting}

Начиная с версии Python 3.11 рекомендуется вместо \verb*|NoReturn| использовать \verb*|Never|, но если проект поддерживает старые версии Python, то документация \url{https://typing.readthedocs.io/en/latest/source/unreachable.html} разрешает использовать \verb*|NoReturn|.

\section{Приемы работы с httpx}

\subsection{Установка}

Установить пакет можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
pip install httpx
\end{lstlisting}

\subsection{Get-запрос}

Например чтобы скачать mps.gz-файл с ресурса MIPLIB 2017, достаточно выполнить следующий код
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import httpx
import pathlib2

BASE_PROBLEMS_URL = "https://miplib.zib.de/WebData/instances/"
PATH_TO_PROBLEMS_DIR = "./data/problems/"
problem_name = "10teams.mps.gz"

try:
	r = httpx.get(
	    BASE_PROBLEMS_URL + problem_name,
	    timeout=5  # в секундах
	)
	response.raise_for_status()
except httpx.RequestError as exc:
    print(f"An error occurred while requesting {exc.request.url!r}.")
except httpx.HTTPStatusError as exc:
    print(f"Error response {exc.response.status_code} while requesting {exc.request.url!r}.")

problem = r.read()
pathlib2.Path(PATH_TO_PROBLEMS_DIR + problem_name).write_bytes(problem)
\end{lstlisting}

\section{Приемы работы с pytest}

\subsection{Особенности импорта}

Пусковой сценарий проекта обычно располагается в директории \verb|./src|. В этом случае сканирование окружения на предмет поиска пользовательских пакетов и модулей начинается с той директории, в которой \emph{лежит} этот пусковой сценарий, то есть с директории \verb|./src|
\begin{lstlisting}[
style = bash,
numbers = none
]
project_root/
    src/
        common/  # пакет
            __init__.py
            logger.py
            exceptoins.py
        units/  # пакет
            __init__.py
            fix_vars.py
            base_unit.py
            solver.py
        strategy_manager.py
        run.py
\end{lstlisting}

Тогда импорт в самом сценарии может выглядеть так
\begin{lstlisting}[
title = {\sffamily run.py},
style = ironpython,
numbers = none
]
# путь отсчитывается от той директории, в которой лежит run.py
from common.logger import make_logger
from strategy_manager import StrategyManager
...
\end{lstlisting}

В модулях пути тоже отсчитываются от той директории, в которой \emph{лежит} пусковой сценарий
\begin{lstlisting}[
title = {\sffamily solver.py},
style = ironpython,
numbers = none
]
from common.logger import make_logger
from units.base_unit import Unit
...
\end{lstlisting}

В тестах можно указывать пути от той же директории \verb|./src|, то есть
\begin{lstlisting}[
title = {\sffamily test\_solver.py},
style = ironpython,
numbers = none
]
import pytest
# путь отсчитывается от директории ./src
from common.exceptions import HiGHS
from units.solver import Solver

@pytest.mark.unit
def test_solver_unit_highs_with_unsupported_solver_name():
    ...
\end{lstlisting}

Но запускать тесты нужно будет так
\begin{lstlisting}[
style = bash,
numbers = none
]
# требуется включить директорию ./src в список путей поиска
$ PYTHONPATH=./src pytest -v
$ PYTHONPATH=./src pytest -v --cov=. --cov-report=html
\end{lstlisting}

\section{Ошибка ValueError: generator already executing в многопоточных приложениях с генераторами}

Ошибка <<ValueError: generator already executing>> возникает когда потоки пытаются одноврменно обратиться к генератору. Можно просто добавить блокировку на вызов следующего метода
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import threading


class ThreadSaveGenerator:
	def __init__(self, gen):
		self.gen = gen
		self.lock = threading.Lock()
	
	def __iter__(self):
		return self._next()
	
	def _next(self):
		with self.lock:
			return self.gen
\end{lstlisting}

Затем нужно просто <<пропустить>> генератор через этот класс и пользоваться генератором как раньше
\begin{lstlisting}[
style = ironpython,
numbers = none
]
conss = ThreadSaveGenerator(self._make_generator(model))

for cons in conss:
    # что-то делаем
\end{lstlisting}



\section{Раскраска ячеек в Jupyterlab}

Чтобы покрасить ячейку в заданный нужно добавить следующие функции в блокнот
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from IPython.core.magic import register_cell_magic
from IPython.display import HTML, display

def set_background(color):    
	script = (
		"var cell = this.closest('.jp-CodeCell');"
		"var editor = cell.querySelector('.jp-Editor');"
		"editor.style.background='{}';"
		"this.parentNode.removeChild(this)"
	).format(color)

	display(HTML('<img src onerror="{}" style="display:none">'.format(script)))

@register_cell_magic
	def background(color, cell):
	set_background(color)
	return eval(cell)
\end{lstlisting}

Затем нужно просто запустить ячейку с магической командой \verb|%%background _color_|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%background red
# здесь какой-то код
\end{lstlisting}

\section{Разреженные матрицы \texttt{LIL} и \texttt{CSC}}

Для представления больших матриц (тысячи строк на тысячи столбцов), которые ограничиваются небольшим числом операций, удобно использовать \verb|scipy.sparse.lil_matrix|, то есть матрицы в формате списка списков разреженных матриц. Такие матрицы эффективны с точки зрения заполнения. Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from scipy.sparse import lil_matrix, csc_matrix

_matrix = lil_matrix((n_conss, n_vars), dtype=np.int8)

conss_gen = ((cons_name, cons) for cons_name, cons in model.all_conss.items())
for cons_name, cons in tqdm(conss_gen, total=n_conss, desc="Building sparse matrix"):
	cons_idx = cons_name_to_cons_idx.get(cons_name)
	_var_names_context = list(cons.keys())
	var_idxs = var_name_to_var_idx.loc[_var_names_context].values.tolist()
	_matrix[cons_idx, var_idxs] = 1
\end{lstlisting}

Но с точки зрения доступа по столбцам эффективнее использовать разреженные матрицы в формате сжатого разреженного столбца -- так как LIL-матрицы строко-ориентированные
\begin{lstlisting}[
style = ironpython,
numbers = none
]
_matrix.tocsc()
\end{lstlisting}

Теперь можно эффективно получить множество индексов столбцов, содержащих ненулевые элементы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
_set_context_var_idxs: t.Set[int] = set(
    self._matrix[self._matrix.getcol(var_idx).nonzero()[0], :].nonzero()[1]
)
\end{lstlisting}





\section{Метод \texttt{\_\_repr\_\_} и модуль \texttt{inspect}}

Метод \verb|__repr__| предназначен для вывода полезной информации на шаге отладки, а метод \verb|__str__| -- вывода полезной информации для пользователей. При этом принято, чтобы метод \verb|__repr__| возвращал такую строку, обернув которую функцией \verb|eval()|, можно было получить экземпляр класса.
	
Для того чтобы специальный метод \verb|__repr__| мог аккуратно выводить сигнатуру класса удобно воспользоваться модулем \verb|inspect|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import inspect

class MyClass:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
        
    def __repr__(self):
        _args: t.List[str] = []
        # аргументы класса: name и age
        _class_args = tuple(inspect.signature(type(self)).parameters.keys())
        _obj_attrs = self.__dict__
        
        for key, value in _obj_attrs.items():
            if key in _class_args:
                # обязательно использовать сырое форматироваие !r
                _args.append(f"{key}={value!r}")  
        args = ", ".join(_args)
        
        return f"{type(self).__name__}({args})
\end{lstlisting}

Чтобы получить имеющиеся функции в модуле (пусть называется \verb*|promotions|) можно сделать так \cite[\strbook{343}]{ramalho:python-2022}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import promotions
import inspect

promos = [func for _, func in inspect.getmembers(promotions, inspect.isfunction)]
\end{lstlisting}

\section{ Интерфейсы, протоколы и ABC}

Объектно-ориентированное программирование -- это об интерфейсах. Хотите понять, что делает тип в Python, -- узнайте. какие методы он предоставляет.

Начиная с Python 3.8 существует 4 способа определения и использования интерфейсов \cite[\strbook{413}]{ramalho:python-2022}:
\begin{itemize}
	\item \emph{Утиная типизация}: подход к типизации, по умолчанию принятый в Python с момента его возникнования. Утиная типизация это игнорирование фактического типа объекта и акцент на том, чтобы объект реализовывал методы с именами, сигнатурами и семантикой, требуемыми для конкретного применения. В Python это сводится в основном к тому, чтобы избегать использование функции \verb*|isinstance()| для проверки типа объекта \cite[\strbook{422}]{ramalho:python-2022}. Очень часто бывает, что во время выполнения утиная типизация -- лучший подход к проверке типа: вместо того чтобы вызывать \verb|isinstance| или \verb*|hasattr|, просто поробуйте выполнить над объектом нужную операцию и обработайте исключения \cite[\strbook{446}]{ramalho:python-2022}. Яркий пример \emph{утиной типизации}
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
class Vector:
	...
	def __mul__(self, scalar):
	    try:
	        factor = float(scalar)
	    except TypeError:
	        return NotImplemented
	    
	    return Vector(n * factor for n in self)
	
	def __rmul__(self, scalar):
	    return self * scalar
\end{lstlisting}

В этом примере метод \verb|__mul__| не проверяет тип \verb*|scalar| явно, а пытается преобразовать его в тип \verb|float| и возвращает \verb*|NotImplemented|, если эта попытка завершается неудачно. Метод \verb|__rmul__| просто вычисляет произведение \verb*|self * scalar|, делегируя всю работу методу \verb|__mul__|.
	
	\item \emph{Гусиная типизация}: этот подход поддерживается абстрактными базовыми классами; в его основе лежит сравнение объектов с ABC, выполняемое на этапе выполнения. Гусиная типизация означает следующее: вызов \verb|isinstance(obj, cls)| теперь считается приемлемым, но при условии, что \verb*|cls| -- абстрактный базовый класс, то есть метаклассом \verb*|cls| является \verb|abc.ABCMeta|. Пусть имеется класс \verb*|FrenchDeck|, и требуется проверить его тип следующим образом: \verb|issubclass(FrenchDeck, Sequence)|. Для этого можно сделаеть его виртуальным подклассом ABC \verb*|Sequence|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collections.abc import Sequence
Sequence.register(FrenchDeck)
\end{lstlisting}

Пример \emph{гусиной типизации}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Vector:
    ...
    def __matmul__(self, other):
        if (isinstance(other, abc.Sized) and isinstance(other, abc.Iterable)):
            if len(self) == len(other):
                return sum(a * b for a, b in zip(self, other))
            else:
                raise ValueError("@ requires vectors of equal length")
        else:
            return NotImplemented
    
    def __rmatmul__(self, other):
        return self @ other
\end{lstlisting}

Здесь оба операнда должны реализовывать методы \verb*|__len__| (\verb|abc.Sized|) и \verb*|__iter__| (\verb|abc.Iterable|).
	
	\item \emph{Статическая типизация}: поддерживается с помощью модуля \verb*|typing|.
	
	\item \emph{Статическая утиная типизация}: поддерживается подклассами класса \verb*|typing.Protocol|, и также проверяется внешними программами.
\end{itemize}

Реализации метода \verb*|__getitem__()| достаточно для \cite[\strbook{414}]{ramalho:python-2022}:
\begin{itemize}
	\item получения элементов по индексу,
	
	\item поддержки итерирования,
	
	\item поддержки оператора \verb*|in|.
\end{itemize}

Специальный метод \verb*|__getitem__()| -- ключ к протоколу последовательности. PEP 544 позволяет создавать подклассы \verb*|typing.Protocol| с целью определить, какие методы должен реализовывать (или унаследовать) класс, чтобы не раздражать программу статической проверки типов.

Между динамическим и статическим протоколами есть два основных различия \cite[\strbook{415}]{ramalho:python-2022}:
\begin{itemize}
	\item объект может реализовать только часть \emph{динамического} протокола и при этом быть полезным; но чтобы удовлетворить \emph{статическому} протоколу, объект должен предоставить \emph{все методы}, объявленные в классе протокола, даже если некоторые из них программе не нужны,
	
	\item статические протоколы можно проверить с помощью программ статической проверки типов, динамические -- нельзя.
\end{itemize}

Помимо статических протоколов, Python предлагает еще один способ программно определить явный интерфейс: абстрактный базовый класс.

Правильно написанный подкласс абстрактного базового класса \verb*|Sequence| должен реализовывать методы \verb*|__getitem__()| и \verb*|__len__()| (унаследованный от \verb*|Sized|) \cite[\strbook{416}]{ramalho:python-2022}.

{\color{blue}Даже если метода \verb*|__iter__()| у объекта нет, но есть метод \verb*|__getitem__()|, Python будет считать \emph{объект итерируемым}. Поскольку если Python находит метод \verb*|__getitem__()| и не имеет ничего лучше, то он пытается обходить объект, вызывая этот метод с целочисленными индексами, начиная с 0} \cite[\strbook{416}]{ramalho:python-2022}. 

Короче говоря, осознавая важность структур данных, обладающих свойствами последовательностей, Python ухитряется заставить \emph{итерирование} и \emph{оператор} \verb*|in| работать, вызывая метод \verb*|__getitem__()| в случае, когда методы \verb*|__iter__()| и \verb*|__contains__()| отсутсвуют.

\subsection{Гусиная типизация}

В Python используются абстрактные базовые классы, чтобы определить интерфейсы для явной проверки типов \emph{во время выполнения}. Они также поддерживаются программами статической проверки типов.

Гусиная типизация -- это \emph{подход к проверке типов} во время выполнения, основанный на применении абстактных базовых классов.

Однако и при использовании абстрактных базовых классов нужно помнить, что злоупотребление функцией \verb*|isinstance| может быть признаком <<дурно пахнущего кода>> -- плохо спроектированной объектно-ориентированной программы.

Обычно \emph{НЕ} должно быть цепочек предложений \verb*|if/elif/else|, в которых с помощью \verb*|isinstance| определяется тип объекта и в зависимости от него выполняются те или иные действия; для этой цели следует использовать \emph{полиморфизм}, то есть проектировать классы так, чтобы интерпретатор сам вызывал правильные методы, а не <<зашивать>> логику диспетчеризации в блоки \verb*|if/elif/else| \cite[\strbook{425}]{ramalho:python-2022}.

{\color{blue}
Важнейшая характеристика \emph{гусиной типизации} -- возможность регистрировать класс как \emph{виртуальный подкласс} абстрактного базового класса, даже без наследования. При этом мы обещаем, что класс честно реализует интерфейс, определенный в абстрактном базовом классе, а Python верит нам на слово, \emph{\color{red}не производя проверку}. Если мы соврем, то будем наказаны исключением во время выполнения.
}

Это делается путем вызова метода \verb*|register| абстрактного базового класса. В результате зарегистрированный класс становится виртуальным подклассом ABC и распознается в качестве такового функцией \verb*|issubclass|, \emph{\color{red}однако не наследует ни методы, ни атрибуты ABC}.

{\color{red}
	Виртуальные подклассы \emph{не наследуют ABC}, для которых зарегистрированы. Их согласованность с интерфейсом ABC \emph{не проверяется никогда}, даже в момент создания экземпляра. Кроме того, программы статической проверки типов не могут обрабатывать виртуальные классы.
}

И наследование ABC, и регистрация в качестве виртуального подкласса ABC -- явные способы сделать так, чтобы проходили проверки с помощью функции \verb*|issubclass|, а равно и проверки с помощью функции \verb*|isinstance|, которая опирается на \verb*|issubclass|. Но некоторые ABC поддерживают также структурную типизацию \cite[\strbook{440}]{ramalho:python-2022}.

ABC чащего всего используются в сочетании с \emph{номинальной типизацией}. Когда класс \verb*|Sub| \emph{явно наследует} \verb*|AnABC| или \emph{регистрируется в качестве виртуального подкласса} \verb*|AnABC|, имя \verb*|AnABC| связывается с классом \verb*|Sub|, именно поэтому во время выполнения вызов \verb|issubclass(AnABC, Sub)| возвращает \verb*|True|.

Напротив, \emph{структурная типизация} подразумевает изучение структуры открытого интерфейса объекта с целью определить его тип: \emph{объект совместим с типом, если он реализует все методы}, определенные типе (то есть другими словами, является \emph{подтипом}). \emph{Динамическая} и \emph{статическая утиные типизации} -- два подхода к \emph{структруной типизации} \cite[\strbook{441}]{ramalho:python-2022}.

Класс может быть распознан как \emph{виртуальный подкласс} ABC \emph{даже без регистрации}

\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Struggle:
    def __len__(self): return 42
    
from collections.abc import Sized

isinstance(Struggle(), Sized)  # True
issubclass(Struggle, Sized)  # True
\end{lstlisting}

Функция \verb*|issubclass| (а значит, и \verb*|isinstance|) считает класс \verb*|Struggle| подклассом \verb*|abc.Sized|, потому что \verb*|abc.Sized| реализует специальный метод класса \verb*|__subclasshook__|. 

Метод \verb*|__subclasshook__| в классе \verb*|Sized| проверяет, имеет ли переданный в аргументе класс атрибут с именем \verb*|__len__|. Если да, то класс считается виртуальным подклассом \verb*|Sized| \cite[\strbook{441}]{ramalho:python-2022}.

Вот так метод \verb*|__subclasshook__| позволяет ABC поддержать структурную типизацию. Несмотря на наличие формального определения интерфейса в ABC и скрупулезных проверок, осуществляемых функцией \verb*|isinstance|, в определенных контекстах вполне можно использовать никак не связанный с ABC класс просто потому, что в нем реализован определенный метод (или потому, что он постарался убедить \verb*|__subclasshook__|, что за него можно поручиться) \cite[\strbook{442}]{ramalho:python-2022}.

Лично я не готов поверить, что класс с именем \verb*|Spam|, который реализует или наследует методы \verb*|load|, \verb*|pick|, \verb*|inspect| и \verb*|loaded|, гарантировано ведет себя как \verb*|Tombola|. Пусть уж лучше программист явно подтвердит это, сделав \verb*|Spam| подклассом \verb*|Tombola| или хотя бы зарегистрировав его: \verb*|Tombola.register(Spam)|. 

\subsection{Статические протоколы}

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from typing import TypeVar, Protocol

T = TypeVar("T")

class Repeatable(Protocol):
    def __mul__(self: T, repeat_count: int) -> T: ...

RT = TypeVar("RT", bound=Repeatable)

def double(x: RT) -> RT:
    return x * 2
\end{lstlisting}

Параметр \verb*|self| обычно не аннотируется -- предполагается, что его тип -- сам класс. Здесь мы используем \verb*|T|, чтобы тип результата гарантированно совпадал с типом \verb*|self|. 

Номинальный тип фактического аргумента \verb*|x|, переданного \verb*|double|, не играет роли, коль скоро он умеет квакать -- т.е. реализует метод \verb*|__mul__|.

На карте типизации \verb*|typing.Protocol| располагается в области статической проверки. Но при определении подкласса \verb*|typing.Protocol| мы можем использовать декоратор \verb*|@runtime_checkable|, чтобы протокол поддерживал проверки с помощью функции \verb*|isinstance/issubclass| во время выполнения.

\begin{lstlisting}[
title = {\sffamily Исходный код протокола \texttt{typing.SupportsComplex}},
style = ironpython,
numbers= none
]
@runtime_checkable
class SupportComplex(Protocol):
    __slots__ = ()
    
    @abstractmethod
    def __complex__(self) -> complex:
        pass
\end{lstlisting}

В процессе \emph{статической проверки типов} объект будет считаться \emph{совместимым с} протоколом \verb|SupportsComplex|, если он реализует метод \verb*|__complex__|, принимающий только аргумент \verb*|self| и возвращающий \verb*|complex|.

Благодаря применению декоратора класса \verb*|@runtime_checkable| к \verb*|SupportsComplex| этот протокол теперь можно использовать в сочетании с функцией \verb*|isinstance|.

Если требуется проверить, верно ли, что объект \verb*|c| имеет тип \verb*|complex| или \verb*|SupportsComplex|, то можем предоставить кортеж типов в качестве второго аргумента \verb*|isinstance|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
isinstance(c, (complex, SupportsComplex))
\end{lstlisting}

Встроенный тип \verb*|complex|, а также типы NumPy \verb*|complex64| и \verb*|complex128| зарегистрированы как виртуальные подклассы \verb|numbers.Complex| и потому проходят проверку с помощью \verb*|isinstance|.

Очень часто бывает, что во время выполнения утиная типизация -- лучший подход к проверке типа: вместо того чтобы вызывать \verb|isinstance| или \verb*|hasattr|, просто попробуйте выполнить над объектом нужную операцию и обработайте исключения.

Пример. Дан объект \verb|o|, который требуется использовать как комплексное число, -- можно подойти к решению следующим образом:
\begin{lstlisting}[
style = ironpython,
numbers = none
]
if isinstance(o, (complex, SupportsComplex)):
    # to something
else:
    raise TypeError("o must be convertible to complex")
\end{lstlisting}

Гусиная типизация подразумевала бы использование ABC \verb*|numbers.Complex|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
if isinstance(o, numbers.Complex):
    # do something
else:
    raise TypeError("...")
\end{lstlisting}

Л. Ромальо предпочитает использовать утиную типизацию и принцип EAFP (it's easier to ask for fogiveness than permission) -- проще попросить прощения, чем испрашивать разрешения
\begin{lstlisting}[
style = ironpython,
numbers = none
]
try:
   c = complex(o)
except TypeError as exc:
    raise TypeError("...") from exc
\end{lstlisting}

Общая проблема: функции \verb|isinstance/issubclass| смотрят только на наличие или отсутствие методов, не проверяя их сигнатуры, а уж тем более аннотации типов \cite[\strbook{448}]{ramalho:python-2022}.

В классе \verb*|Vector2d| можно разместить метод следующего вида
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from __future__ imoprt annotations  # NB

class Verctor2d:
    ...
    
    @classmethod
    def fromcomplex(cls, datnum: SupportsComplex) -> Vector2d:  # NB
        c = complex(datnum)
        return cls(c.real, c.imag)
\end{lstlisting}

Тип возвращаемого \verb|fromcomplex| значения может быть \verb*|Vector2d|, если в начале модуля находится предложение \verb|from __future__ import annotations|. Этот импорт приводит к тому, что аннотации типов сохраняются в виде строк, а не вычисляются на этапе импорта, когда интерпретатор обрабатывает определения функций. Если бы \verb|annotations| не импортировался, то ссылка \verb*|Vector2d| была бы в этой точке недопустима (класс еще не полностью определен) и ее следовало бы записать в виде строки \verb*|'Vector2d'|, как если бы это была опережающая ссылка \cite[\strbook{449}]{ramalho:python-2022}.

\section{Итераторы, генераторы и классические сопрограммы}

Если просматривается набор данных, не помещающийся целиком в память, то нужен способ выполнять ее \emph{лениво}, то есть по одному элементу и по запросу. Именно это и делает Итератор. 

Любая стандартная коллекция в Python является \emph{итерируемым объектом}, то есть предоставляет \emph{итератор}, который используется для поддержки следующих операций \cite[\strbook{556}]{ramalho:python-2022}:
\begin{itemize}
	\item циклов \verb|for|,
	
	\item списковых, словарных и множественных включений, 
	
	\item распаковки операций присваивания,
	
	\item конструирования экземпляров коллекций.
\end{itemize}

Всякий раз как интерпретатору нужно обойти объект \verb*|x|, он автоматически вызывает функцию \verb|iter(x)|.

Встроенная функция \verb*|iter| выполняет следующие действия \cite[\strbook{559}]{ramalho:python-2022}:
\begin{itemize}
	\item Смотрит, реализует ли объект метод \verb*|__iter__|, и, если да, вызывает его, чтобы получить итератор,
	
	\item Если метод \verb|__iter__| не реализован, но реализован метод \verb*|__getitem__|, то Python создает итератор, который пытается извлекать элементы по порядку, начиная с индекса 0,
	
	\item Если и это не получается, то возбуждается исключение -- обычно с сообщением <<'C' object is not iterable>>
\end{itemize}

Именно поэтому любая последовательность в Python является итерируемой: все они реализуют метод \verb|__getitem__|. На самом деле стандартные последовательности реализуют и метод \verb*|__iter__|, а специальная обработка метода \verb|__getitem__| оставлена \emph{только ради обратной совместимости} \cite[\strbook{559}]{ramalho:python-2022}.

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Spam:
    def __getitem__(self, i):
        print("->", i)
        raise IndexError()
        
spam = Spam()
iter(spam)  # <iterator object ...>
list(spam)
# -> 0
# []
from collections import abc
isinstance(spam, abc.Iterable)  # False
\end{lstlisting}

Если класс предоставляет метод \verb*|__getitem__|, то встроенная функция \verb|iter()| принимает \emph{экземпляр} этого \emph{класса} в качестве \emph{итерируемого объекта} и строит по нему \emph{итератор}. Механизм итерирования Python будет вызывать \verb*|__getitem__| с индексами, начинающимися с 0, и воспринимать исключение \verb|IndexError| как сигнал о том, что элементы кончились.

Итерируемый объект -- любой объект, от которого встроенная функция \verb*|iter| может получить \emph{итератор}. Объекты, которые реализуют метод \verb|__iter__|, возвращающий \emph{итератор}, являются итерируемыми. \emph{Последовательности} всегда \emph{итерируемы}, поскольку это объекты, реализующие метод \verb*|__getitem__|, который принимает индексы, начинающиеся с нуля \cite[\strbook{561}]{ramalho:python-2022}.

Итераторы в Python следует считать не типом, а \emph{протоколом}. Лучше не проверять тип итератора, а использовать функцию \verb|hasattr| для проверки наличия атрибутов <<\verb*|__iter__|>> и <<\verb|__next__|>> \cite[\strbook{563}]{ramalho:python-2022}.

Объект считается \emph{итерируемым}, если реализует метод \verb|__iter__| \cite[\strbook{559}]{ramalho:python-2022}.

Лучший способ узнать, является ли объект итератором, -- вызвать функцию\\ \verb|isinstance(x, collections.abc.Iterator)|. Благодаря методу \verb|Iterator.__subclasshook__| эта проверка работает даеж тогда, когда класс не является ни настоящим, ни виртуальным подклассом \verb*|Iterator|.

Любая функция в Python, в теле которой встречается ключевое слово \verb|yield|, называется \emph{генераторной функцией} -- при вызове она возвращает \emph{объект-генератор}. Иными словами, генераторная функция -- фабрика генераторов.

\emph{Объекты-генераторы} реализуют интерфейс \verb*|Iterator|, поэтому являются также \emph{итерируемыми объектами} \cite[\strbook{569}]{ramalho:python-2022}.

Генераторная функция не возбуждает исключение \verb*|StopIteration|, когда значений не остается она просто выходит. Другими словами, генераторная функция прсото возвращает управление, а исключение \verb|StopIteration| возбуждает объект-генератор (в полном соответствии с протоколом \verb*|Iterator|).

Вызов генераторной функции возвращает генератор. А генератор отдает значения.

\emph{Генераторное выражение} возвращает \emph{объект-генератор}. Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
RE_WORD = re.compile(r"\w+")

class Sentence:
    def __init__(self, text):
        self.text = text
        
    def __repr__(self):
        return f"..."
        
    def __iter__(self):
        # ВОЗВРАЩАЕТСЯ генераторное выражение
        return (match.group() for match in RE_WORD.finditer(self.text))
\end{lstlisting}

Конечный результат не изменился: код, вызывающий \verb|__iter__|, получает объект-генератор.

Генераторные выражения -- не более чем синтаксический сахар: их всегда можно заменить генераторными функциями, но иногда выражение удобнее.

Если генераторное выражение занимает больших двух строк, то рекомендуется использовать генераторную функцию.

В официальной документации и кодовой базе Python терминология, относящаяся к итераторам и генераторам, противоречива и постоянно изменяется. Рамальо предлагает следующие определения \cite[\strbook{574}]{ramalho:python-2022}:
\begin{itemize}
	\item \emph{Итератор} -- общий термин, обозначающий любой объект, который реализует метод \verb*|__next__|. Итераторы предназначены для порождения данных, потребляемых клиентским кодом, т.е. кодом, который управляет итератором посредством цикла \verb|for| или другой итеративной конструкции либо путем явного вызова функции \verb*|next(it)| для итератора. На практике большинство итераторов, встречающихся в Python, являются генераторами. 
	
	\item \emph{Генератор} -- \underline{итератор}, построенный компилятором Python. Для создания генератора мы не реализуем метод \verb|__next__|. Вместо этого используется ключевое слово \verb*|yield|, в результате чего получается \emph{генераторная функция}, то есть фабрика \emph{объектов-генераторов}. Генераторное выражение -- это еще один способ построить объект-генератор. Объекты-генераторы предоставляют метод \verb|__next__|, то есть являются генераторами.
\end{itemize}

\remark{
В глоссарии Python недавно появился термин \emph{генераторный итератор}, так называют объекты, построенные генераторными функциями, тогда как в статье о генераторных выражениях говорится, что они возвращают <<итератор>>. Но в обоих случаях, если верить Python, возвращаются \emph{объекты-генераторы}
}

Выражение \verb|yield from| позволяет генератору делегировать работу субгенератору.

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def tree(cls):
    yield cls.__name__, 0
    yield from sub_tree(cls, 1)
    
def sub_tree(cls, level):
    for sub_cls in cls.__subclasses__():
        yield sub_cls.__name__, level
        yield from sub_tree(sub_cls, level + 1)

def display(cls):
    for cls_name, level in tree(cls):
        indent = " " * 4 * level
        print(f"{indent}{cls_name}")
        
        
if __name__ == "__main__":
    display(BaseException)
\end{lstlisting}

В любом нормальном пособии по рекурсии подчеркивается важность базы, позволяющей избежать бесконечной рекурсии. Неявное условие есть в цикле \verb|for|: если \verb*|cls.__subclasses__()| возвращает пустой список, то тело цикла не выполняется, так что рекурсивного вызова не будет. Базовым является случай, когда класс \verb|cls| \emph{не имеет подклассов}. Тогда \verb*|sub_tree| ничего не отдает, а просто возвращает управление \cite[\strbook{595}]{ramalho:python-2022}.

Функции, принимающие итерируемые объекты в качестве аргументов, можно аннотировать с помощью \verb|collections.abc.Iterable| (или \verb*|typing.Iterable|, если нужно обязательно поддержать версию Python 3.8 или более ранние)
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
from collections.abc import Iterable

FromTo = tuple[str, str]

def zip_replace(text: str, changes: Iterable[FromTo]) -> str:
    for from_, to in changes:
        text = text.replace(from_, to)
    return text
\end{lstlisting}

Начиная с версии Python 3.10 \verb|FromTo| должна иметь аннотацию типа \verb*|typing.TypeAlias|, чтобы прояснить назначение этой строки
\begin{lstlisting}[
style = ironpython,
numbers = none
]
FromTo: TypeAlias = tuple[str, str]
\end{lstlisting}

Типы \verb|Iterator| встречаются не так часто, как \verb*|Iterable|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collections.abc import Iterator

def fibonacci() -> Iterator[int]:
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
\end{lstlisting}

Тип \verb|Iterator| используется для генераторов, оформленных в виде функции с \verb*|yield|, а также итераторов, написанных <<вручную>> как классы с методом \verb*|__next__|. Существует также тип \verb|collections.abc.Generator| (и соответствующий объявленный {\color{red}нерекомендуемым тип \verb|typing.Generator|}), который можно использовать для аннотирования объекто-генераторв, но он слишком многословен для генераторов в роле итераторов \cite[\strbook{597}]{ramalho:python-2022}.

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Генераторное выражение, отдающее строки
long_kw: Iterator[str] = (k for k kwlist if len(k) >= 4)
\end{lstlisting}

\verb*|abc.Iterator[str]| совместим с \verb|abc.Generator[str, None, None]|. {\color{blue}\verb*|Iterator[T]| -- это краткое обозначение \verb|Generator[T, None, None]|}. Обе аннотации означают <<\emph{генератор}, который \underline{отдает} объект типа \verb|T|, но \emph{не потребляет} и \emph{не возвращает} значений>>. Генераторы, способные потреблять и возвращать значения, называются сопрограммами.

Генераторы чаще используются в роли простых итераторов.

Единственное разумное действие с \emph{генератором}, используемым \emph{в роли итератора}, -- вызов метода \verb*|next(it)| прямо или косвенно посредством цикла \verb*|for| и других форм итерирования.

Есть еще тип \verb*|typing.Coroutine| (объявленный нерекомендуемым) и \verb|collections.abc.Coroutine| (обобщенный начиная с версии Python 3.9) предназначены для аннотирования \emph{только платформенных}, но \emph{не классических сопрограмм}.

Если требуется использовать аннотации типов в сочетании с классическими сопрограммами, то придется испытывать замешательство, аннотируя их как \verb|Generator[YieldType, SendType, ReturnType]|.

Из презентаций Бизли \cite[\strbook{599}]{ramalho:python-2022}:
\begin{itemize}
	\item генераторы порождают данные для итерирования,
	
	\item сопрограммы являются потребителями данных,
	
	\item сопрограммы не имеют никакого отношения к итерированию.
\end{itemize}

Пример сопрограммы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def averager() -> Generator[float, float, None]:
    total = 0.0
    count = 0
    average = 0.0
    while True:
        term = yield average
        total += term
        count += 1
        average = total / count
        
coro_avg = averager()
next(coro_avg)  # 0.0
coro_avg.send(10)  # 10
coro_avg.send(30)  # 20
\end{lstlisting}

Здесь не нужны ни атрибуты экземпляра, ни замыкания. Потому-то сопрограммы и являются привлекательной альтернативой обратным вызовам при асинхронном программировании -- они сохраняют локальное состояние между активациями.

В этом тесте вызов \verb*|next(coro_avg)| заставляет сопрограмму дойти до \verb|yield|, при этом будет отдано начальное значение \verb*|average|. Запустить сопрограмму можно также, вызвав \verb|coro_avg.send(None)|, -- именно так и поступает встроенная функция \verb*|next()|. Но отправить какое-то значение, кроме \verb|None|, нельзя, потому что сопрограмма может принимать отправленные значения, только когда приостановлена в точке \verb*|yield|. Вызов \verb|next()| или \verb*|.send(None)|, чтобы продвинуть выполнение к первому предложению \verb|yield|, называется <<инициализацией сопрограммы>>.

\section{Замечание о хвостовой рекурсии в Python}

{\color{red}В Python нет PTC (Proper Tail Calls, \emph{чисто хвостовой рекурсии})}, поэтому от написания хвостово-рекурсивных функций мы никакого навара не получим. Хвостовая рекурсия имеет место, когда функция возвращает результат некоторого вызова функции -- самой себя или какой-то другой \cite[\strbook{643}]{ramalho:python-2022}.

Проблема в том, что даже в языках, где PTC реализована, дивиденты получают не все рекурсивные функции, а только специально написанные, так чтобы имел место хвостовой вызов. Если PTC поддерживается языком, то \emph{интерпретатор}, \emph{видя хвостовой вызов}, переходит прямо в тело вызываемой функции, \emph{не создавая новый кадр стека}, \emph{что экономит память}. Есть также компилируемые языки, в которых реализована PTC, иногда в качестве оптимизации, включаемой по желанию.

Если в языке нет никакого механизма итераций, кроме рекурсии, то PTC необходима из практических соображений.

В CPython PTC не реализована и, скорее всего, никогда не будет. PTC усложняет отладку для всех, а преимущества получают только те немногие, кто предпочитает использовать \emph{рекурсию вместо итераций} \cite[\strbook{644}]{ramalho:python-2022}.

\section{Модели конкурентности в Python}

Конкурентное или параллельное программирование -- даже ученые, строго следящие за употреблением терминологии, не согласны в том, как использовать эти термины. С точки зрения Роба Пайка, \emph{параллелизм} -- частный случай \emph{конкурентности}. Все параллельные системы являются конкурентными, но обратное неверно.

Современный нойтбук с 4 ядрами спокойно выполняет более 200 процессов в каждый момент времени при нормальной повседневной загрузке. Чтобы выполнить 200 задач параллельно, нужно 200 ядер. Поэтому на практике большая часть вычислений производится \emph{кокурентно}, а \emph{не параллельно} \cite[\strbook{646}]{ramalho:python-2022}.

Когда мы вызываем функцию, вызывающая программа блокируется, пока функция не вернет управление. В этот момент мы знаем, что функция звершила свою работу, и легко можем получить возвращенное значение.

Эти хорошо знакомые действия неприменимы, когда запускается поток или процесс: нет никакого способа автоматически узнать, когда он завершился, а для получения результатов или ошибок нужно организовать какой-то коммуникационный канал, например очередь сообщений.

\emph{Конкурентность} -- способность обрабатывать несколько задач, \emph{чередуя выполнение} или параллельно (если это возможно), так что каждая задача в конечном счете доходит до конца или завершается с ошибкой. Одноядерный процессор допускает конкурентность, если работает под управлением планировщика ОС, который \underline{чередует} выполнение ожидающих задач.

\emph{Параллелизм} -- способность выполнять несколько вычислений \emph{одновременно}. Для этого необходим многоядерный процессор, несколько процессоров, графический процессор или кластер из нескольких компьютеров.

\emph{Единица выполнения} -- общий термин для объектов, выполняющих код конкурентно, каждый из которых имеет независимые от других состояния и стек вызовов. Python поддерживает три вида единиц выполнения: потоки, процессы и сопрограммы.

\emph{Процесс} -- экземпляр компьютерной программы во время ее выполнения, которому выделены память и квант процессорного времени. Каждый процесс изолирован в своем адресном пространстве. Процессы взаимодействуют посредством каналов, сокетов или отображенных на память файлов -- все они могут передавать только <<голые>> байты. Чтобы передать объект Python из одного процесса в другой, его необходимо сериализовать в виде последовательности байтов. Это дорого, и не все объекты допускают сериализацию.

\emph{Поток} -- единица выполнения внутри одного процесса. Сразу после запуска процесс содержит один -- \emph{главный} -- поток. Процесс может создавать дополнительные потоки, которые будут работать конкурентно. Потоки внутри одного процесса \underline{разделяют} \emph{общее пространство памяти}. Это позволяет потокам совместно использовать данные, но может приводить к повреждению данных, если сразу несколько потоков пытаются обновить один и тот же объект. Поток потребляет меньше ресурсов, чем процесс, для выполнения одной и той же работы.

\emph{Сопрограмма} -- функция, которая может \emph{приостановить} свое выполнение и продолжить позже. В Python \emph{классические сопрограммы} строятся на основе генераторных функций, а \emph{платформенные} определяются с помощью ключевых слов \verb|async def|. В Python \emph{сопрограммы} обычно исполняются \emph{в одном потоке} под управлением \emph{цикла событий}, который работает в том же потоке. Например, каркас \verb|asyncio| предоставляет цикл событий и поддерживающие библиотеки для реализации неблокирующиего ввода-вывода на основе сопрограмм. {\color{blue}Каждая сопрограмма должа \emph{явно уступать процессор} с помощью ключевого слова \verb*|yield| или \verb|await|, чтобы другие части программы могли работать \emph{конкурентно} (\underline{но не параллельно})}. Это означает, что любой блокирующий код внутри сопрограммы блокирует выполнение цикла событий и всех остальных сопрограмм.

Только один поток Python может удерживать GIL в каждый момент времени. Это означает, что только один поток может выполнять Python-код, и от числа процессорных ядер это не зависит \cite[\strbook{650}]{ramalho:python-2022}.

Программист, пишущий на Python не может управлять GIL. Но \emph{встроенная функция} или \emph{расширение}, \underline{написанное на C} или на любом другом языке, имеющем интерфейс к Python на уровне C API, \emph{может освободить GIL} во время выполнения длительной задачи \cite[\strbook{651}]{ramalho:python-2022}.

{\color{blue}
Любая стандартная библиотечная функция Python, делающая \emph{системный вызов}\footnote{Системным вызовом называется обьращение из пользовательского кода к функции, находящейся в ядре операционной системы}, освобождает GIL. Сюда относятся все функции, выполняющие \emph{дисковый ввод-вывод}, \emph{сетевой ввод-вывод}, а также \verb*|time.sleep()|. Многие \textbf{счетные функции} в библиотеках numpy/scipy, а также функции сжатия и распаковки из модулей \verb|zlib| и \verb*|bz2| \emph{также освобождают GIL}.
}

NB: В документации библиотеки joblib \url{https://joblib.readthedocs.io/en/stable/parallel.html} отмечается, что \verb|joblib.Parallel| по умолчанию использует loky-бекэнд для запуска Python-процессов конкурентного выполнения задач на отдельных вычислительных блоках центрального процессора. Это разумное значение по умолчанию для многих задач, но оно может быть связано со значительными накладными расходами, так как входные и выходные данные должны быть сериализованы. {\color{blue}Однако, если известно, что вызываемая функция представляет собой скомпилированное расширение, которое освобождает GIL во время большей части своих вычислений, то гораздо эффективнее для распараллеливания использовать потоки вместо Python-процессов.} Для примера, когда вычислительно емкая часть кода располагается в блоке \verb|with nogil| Cython-функции.

Влияние GIL на сетевое программирование с помощью потоков сравнительно невелико, потому что функции ввода-вывода освобождают GIL, а чтение или запись в сеть всегда подразумевает высокую задержку по сравнению с чтением-записью в память. Следовательно, каждый отдельный поток все равно тратит много времени на ожидание, так что их выполнение можно чередовать без заметного снижения общей пропускной способности.

Состязание за GIL замедляет работу счетных потоков в Python. В таких случаях последовательный однопоточный код проще и быстрее.

Для выполнения счетного Python-кода на нескольких ядрах нужно использовать несколько процессов Python.

\emph{Сопрограммы} по умолчанию вкупе с циклом событий \emph{работают в одном потоке}, поэтому GIL не оказывает на них никакого влияния. Можно использовать несколько потоков в асинхронной программе, но рекомендуется, чтобы и цикл событий, и все сопрограммы исполнялись в одном потоке, а дополнительные потоки выделять для специальных задач \cite[\strbook{652}]{ramalho:python-2022}.

Сопрограммы приводятся в действие \emph{циклом событий}, находящимся на уровне приложения. \emph{\color{blue}Цикл обработки событий управляет очередью ожидающих активаций сопрограмм}, выполняет их \underline{по одной}, отслеживает события, генерируемые операциями ввода-вывода, инициированными сопрограммами, и возвращает управление соответсвующей сопрограмме, когда такое событие происходит. Цикл событий, библиотечные и пользовательские сопрограммы выполняются \emph{в одном потоке} \cite[\strbook{657}]{ramalho:python-2022}.

\verb|asyncio.run(coro())| вызывается из регулярной сопрограммы для управления объектом сопрограммы, который обычно является \emph{точкой входа} в весь асинхронный код программы. Этот вызов \emph{блокирует выполнение}, пока \verb*|coro| не вернет управление. 

\verb|asyncio.create_task(coro())| вызывается из сопрограммы, чтобы \emph{запланировать выполнение другой сопрограммы}. Этот вызов \emph{не приостанавливает} текущую сопрограмму. Он возвращает экземпляр \verb*|Task| -- объект, который обертывает объект сопрограммы и предоставляет методы для управления ей и опроса ее состояния.

\verb|await coro()| вызывается из сопрограммы, чтобы передать управление объекту сопрограммы, возвращенному \verb*|coro()|. Этот вызов \emph{приостанавливает} текущую сопрограмму до возврата из \verb|coro|. Значением выражения \verb*|await| является значение, возвращенное \verb|coro|.

{\color{red}
Вызов сопрограммы как \verb*|coro()| сразу же возвращает объект сопрограммы, но \emph{не выполняет тело функции} \verb|coro|. Активация тел сопрограмм -- задача цикла событий
}

В случае сопрограмм код по умолчанию защищен от прерывания. Требуется явно выполнить \verb*|await|, чтобы другие части программы могли поработать.

По определению в каждый момент времени может работать только одна сопрограмма. Желая добровольно отказаться от владения процессором, мы используем \verb|await|, чтобы уступить управление планировщику. Именно поэтому сопрограмму можно безопасно отменить: по определению, сопрограмма может быть отменена только тогда, когда приостановлена в выражении \verb*|await|, и ничто не мешает произвести очистку, обработав исключение \verb|CancelledError|.

Если задача счетная, то многопоточная программа будет медленнее, чем последовательный код, так как \emph{растет конкуренция за процессоры} и \emph{стоимость конекстного переключения}. Чтобы переключиться на другой поток, ОС должна сохранить регистры процессора и изменить счетчик программы и указатель стека, что влечет за собой дорогостоящие побочные эффекты, например недействительность процессорных кешей и, возможно, выгрузку страниц памяти \cite[\strbook{673}]{ramalho:python-2022}.

Благодаря GIL интерпретатор работает быстрее на одном ядре, а его реализация упрощается. Кроме того, GIL упрощает написание простых расширений с помощью Python/C API.

Сопрграммы лучше масштабируются, потому что потребляют гораздо меньше памяти, чем потоки, а также уменьшают стоимость контекстоного переключения \cite[\strbook{693}]{ramalho:python-2022}.

Основой пакета \verb|concurrent.futures| являются классы \verb*|ThreadPoolExecutor| и \verb|ProcessPoolExecutor|, которые реализуют API, позволяющий передавать вызываемые объекты соответственно потокам или процессам. Оба класса прозрачно управляют внутренним пулом рабочих потоков или процессов и очередью подлежащих выполнению задач.

Максимальное число исполняемых \emph{потоков} \verb*|max_workers| (если равно \verb|None|), начиная с версии Python 3.8, вычисляется как \cite[\strbook{697}]{ramalho:python-2022}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
max_workers = min(32, os.cpu_count() + 4)
\end{lstlisting}

Это значение по умолчанию оставляет как минимум 5 исполнителей для задач ввода-вывода. Оно позволяет задействовать не более 32 процессорных ядра для счетных задач. А это позволяет избежать чрезмерного потребления ресурсов на многоядерных машинах.

\subsection{Где находятся будущие объекты?}

В стандартной библиотеке есть два класса с именем в \verb*|Future|: \verb|concurrent.futures.Future| и \verb*|asyncio.Future|. Экземпляр класса \verb|Future| представляет некое \emph{отложенное вычисление}, завершившееся или нет \cite[\strbook{698}]{ramalho:python-2022}.

\emph{Будущие объекты} инкапсулируют \emph{ожидающие операции}, так что их можно помещать в очереди, опрашивать состояние завершения и получать результаы (или исключения), когда они станут доступны.

Важно понимать, что будущие объекты не следует создавать напрямую: предполагается, что их создает исключительно используемая библиотека, будь то \verb*|concurrent.futures| или \verb|asyncio|. Легко понять, почему это так: объект \verb*|Future| представляет нечто, что должно случиться когда-то в будущем, а единственный способ гарантировать, что это действительно случится, -- запланировать выполнение объекта. 

Прикладной код не должен изменять состояние будущего объекта: его изменит каркас конкурентности, когда представляемое этим объектом вычисление завершиться, а мы не можем управлять тем, когда это произойдет.

Метод \verb|.result()| одинаково работает в обоих классах в ситуации, когда выполнение будущего объекта завершено: либо возвращает результат вызываемого объекта, либо повторно возбуждает исключение, возникшее во время выполнения. Но если выполнение будущего объекта еще не завершено, то метод \verb*|result| ведет себя совершенно по-разному. В объекте класса \verb|concurrent.futures.Future| вызов \verb*|f.result()| \emph{блокирует} вызывающий поток до тех пор, пока не будет готов результат. Метод \verb|asyncio.Future.result| не поддерживает задание тайм-аута, а рекомендуемый способ получения результата будущего объекта заключается в использовании \verb*|await| -- к объектам класса \verb|concurrent.futures.Future| этот подход не применим.

Функция \verb*|concurrent.futures.as_completed| принимает итерируемый объект, содержащий будущие объекты, и возвращает итератор, который \emph{отдает} будущие объекты \emph{по мере их завершения}.

Процессы потребляют больше памяти и запускаются дольше, чем потоки, поэтому ценность \verb|ProcessPoolExecutor| становится очевидной только для счетных задач \cite[\strbook{701}]{ramalho:python-2022}.

Функцией \verb*|executor.map| пользоваться легко, но зачастую желетально получать результаты по мере готовности вне зависимости от порядка подачи исходных данных. Для этого нужна комбинация метода \verb|executor.submit| и функции \verb*|futures.as_completed|. Комбинация \verb|executor.map| и \verb*|futures.as_completed| обладает большей гибкостью, чем \verb|executor.map|, потому что ей можно подавать различные вызываемые объекты и аргументы, тогда как \verb*|executor.map| предназначена для выполнения одного и того же вызываемого объекта с разными аргументами \cite[\strbook{706}]{ramalho:python-2022}.

Метод \verb|executor.submit| планирует выполнение одного вызываемого объекта и возвращает экземпляр класса \verb*|Future|. Первый аргумент -- сам вызываемый объект, остальные -- передаваемые ему аргументы.

\section{Асинхронное программирование}

Начиная с версии Python 3.5 предлагается 3 вида сопрограмм:
\begin{enumerate}
	\item \emph{Платформенная сопрограмма} -- функция, определенная с помощью конструкции \verb|async def|. Можно делегировать работу от одной платформенной сопрограммы другой, воспользовавшись ключевым словом \verb*|await|. Предложение \verb|async def| всегда определяется платформенную сопрограмму, даже если в ее теле не встречается ключевое слово \verb*|await|. Ключевое слово \verb|await| нельзя использовать вне платформенной сопрограммы.
	
	\item \emph{Классическая сопрограмма} -- генераторная функция, которая потребляет данные, отправленные ей с помощью вызовов \verb*|my_coro.send(data)|, и читает эти данные, используя \verb|yield| в выражении.
	
	\item \emph{Генераторная сопрограмма} -- генераторная функция, снабженная декоратором \verb*|@types.coroutine|. Этот декоратор делает генератор совместимым с новым ключевым словом \verb|await|.
\end{enumerate}

\emph{Асинхронный генератор} -- генераторная функция, определенная с помощью конструкции \verb*|async def| и содержащая в теле \verb|yield|. Она возвращает \emph{асинхронный объект-генератор}, предоставляющий метод \verb*|__anext__| для асинхронного получения следующего элемента.

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import asyncio
import socket
from keyword import kwlist

MAX_KEYWORD_LEN = 4

async def probe(domain: str) -> tuple[str, bool]:
    loop = asyncio.get_running_loop()
    try:
        await loop.getaddrinfo(domain, None)
    except socket.gaierror:
        return (domain, False)
    
    return (domain, True)
    
async def main() -> None:
    names = (kw for kw in kwlist if len(kw) <= MAX_KEYWORD_LEN)
    domains = (f"{name}.dev".lower() for name in names)
    coros = [probe(domain) for domain in domains]
    for coro in asyncio.as_completed(coros):
        domain, found = await coro
        mark = "+" if found else " "
        print(f"{mark} {domain}")

if __name__ == "__main__":
    asyncio.run(main())
\end{lstlisting}

Получить ссылку на цикл обработки событий \verb|asyncio| для будущего использования. Функция \verb*|main| должна быть сопрограммой, чтобы в ней можно было использовать \verb|await|. Генератор \verb*|asyncio.as_completed| отдает переданные ему сопрограммы \emph{в порядке их завершения}, а не в порядке подачи (как и \verb|executor.as_completed|). \verb|await| в \verb*|main| не может заблокировать выполнение, так как \verb|as_completed| отдает уже завершенные сопрограммы, но оно все равно необходимо, чтобы получить результат от \verb*|coro|.

\verb*|asyncio.run| запускает цикл обработки событий и возвращает управление только после выхода из него. Это типичный паттерн для скриптов, в которых используется \verb|asyncio|: реализовать \verb*|main| как сопрограмму и выполнить ее внутри блока \verb|if __name__ == "__main__"|.

\verb*|asyncio.as_completed| и \verb|await| могут применяться не только к сопрограммам, но и к \emph{допускающим ожидание объектам}.

Ключевое слово \verb*|for| работает с \emph{итерируемыми объектами}. А ключевое слово \verb*|await| -- с объектами, \emph{допускающими ожидание}.

Конечный пользователь \verb*|asyncio| постоянно сталкивается со следующими объектами, допускающими ожидание:
\begin{itemize}
	\item \emph{объект платформенной сопрограммы}, который мы получаем в результате вызова функции платформенной сопрограммы,
	
	\item \verb|asyncio.Task|, который мы обычно получаем, передав объект сопрограммы\\ функции~\verb|asyncio.create_task()|.
\end{itemize}

Если вы не собираетесь отменять задачу или ждать ее завершения, то и не нужно хранить объект \verb|Task|, возвращенный функцией \verb|create_task|. Достаточно просто создать задачу, чтобы запланировать выполнение сопрограммы.

С другой стороны, мы используем \verb|await other_coro()| (в точках \verb|await| сопрограмма приостанавливается и уступает управление циклу событий), чтобы \emph{выполнить} \verb|other_coro| \emph{немеделенно} и \emph{дождаться ее завершения}, потому что для продолжения работы нужен ее результат, например, \verb|res = await slow()|. 

В синхронной программе пользоавтельская функция запускает цикл событий, планируя начальную сопрограмму с помощью вызова \verb*|asyncio.run|. Каждая пользоваетльская сопрограмма отдает управление следующей с помощью выражения \verb|await|, формируя канал, по которому взаимодействуют библиотека типа HTTPX и цикл событий.

Цепочка \verb*|await| в конце концов достигает низкоуровневого объекта, допускающего ожидание, который возвращает генератор, к которому цикл событий может обращаться в ответ на такие события, как срабатывания таймера или сетевой ввод-вывод.

Используя функции типа \verb|asyncio.gather| и \verb*|asyncio.create_task|, можно создать \emph{\color{blue}несколько конкурентных каналов} {\color{blue}\verb|await|}, что позволяет \emph{конкурентно} выполнять \emph{\underline{несколько} операций ввода-вывода} \emph{в одном цикле событий} \underline{\itshape в одном потоке} \cite[\strbook{728}]{ramalho:python-2022}.

Для достижения максимальной производительности при работе с \verb*|asyncio| мы должны заменить все функции, осущствляющие ввод-вывод, асинхронными версиями, которые активируются в результате выполнения \verb|await| или \verb*|asyncio.create_task|, для того \emph{чтобы управление возвращалось циклу событий}, \emph{пока} функция \emph{ждет} завершения ввода-вывода.

Если не удается переписать блокирующую функцию как сопрограмму, то ее следует запускать в отдельном потоке или процессе.

\subsection{Асинхронные менеджеры контекста}

Пример из документации по драйверу PostgreSQL asyncpg
\begin{lstlisting}[
style = ironpython,
numbers = none
]
tr = connection.transaction()
await tr.start()
try:
    await connection.execute("INSERT INTO mytable VALUES (1, 2, 3)")
except:
    await tr.rollback()
    raise
else:
    await tr.commit()
\end{lstlisting}

Транзакция базы данных естественно ложится на протокол контекстного менеджера: транзакцию нужно начать, изменить данные в \verb|connection.execute|, а затем зафиксировать или откатить в зависимости от того, как прошли изменения.

С помощью \verb*|async with| этот пример можно переписать так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
async with connection.transaction():
    await connection.execute("INSERT INTO mytable VALUES (1, 2, 3)")
\end{lstlisting}

\verb|asyncpg| позволяет обойти отсутствие в PostgreSQL поддержки высокой конкурентности, поскольку реализует пул подключений для внетреннего подключения к самой PostgreSQL.

\emph{Файловый ввод-вывод} -- \emph{блокирующая} операция в том смысле, что чтение и запись файлов занимают в тысячи раз больше времени, чем чтение-запись в память. 

Начиная с Python 3.9 сопрограмма \verb*|asyncio.to_thread| упрощает делегирование файлового ввода-вывода пулу потоков, представляемому библиотекой \verb|asyncio|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
...
await asyncio.to_thread(save_flag, image, f"{cc}.gif")
\end{lstlisting}

Сохранение изображения -- операция ввода-вывода. Чтобы \emph{избежать блокирования цикла событий}, функция \verb*|save_fig| выполняется в \emph{отдельном потоке}.

Сетевые клиенты следует \emph{дросселировать} (то есть ограничивать), чтобы избежать затопления сервера слишком большим количеством конкурентных запросов. 

Семафор -- это примитив синхронизации, более гибкий, чем блокировка. \emph{Семафор} могут удерживать \emph{несколько} сопрограмм, причем максимальное их число настраивается. 

Эффект дросселирования можно достичь путем создания, например, объекта \verb|ThreadPoolExecutor|.

В классе \verb*|asyncio.Semaphore| имеется внутренний счетчик, который уменьшается на 1 всякий раз, как выполняется \verb|await| для метода-сопрограммы \verb*|.acquire()|, и увеличивается на 1 при вызове метода \verb|.release()|, который не является сопрограммой, потому что никогда не блокирует выполнение.

Ожидание \verb*|.acquire()| не приводит к задержке, когда счетчик больше 0, не если счетчик равен 0, то  \verb|.acquire()| приостанавливает ожидающую сопрограмму до тех пор, пока какая-нибудь другая сопрограмма не вызовет \verb*|.release()| для того же семафора, увеличив тем самым счетчик.

Начальное значение счетчика задается при создании объекта семафор

\noindent\verb|semaphore = asyncio.Semaphore(concur_req)|.

Безопаснее использовать \verb|semaphore| как асинхронный контекстный менеджер
\begin{lstlisting}[
style = ironpython,
numbers = none
]
async with semaphore:
    image = await get_flag(client, base_url, cc)
\end{lstlisting}

Этот код гарантирует, что в любой момент времени будет активно не более \verb|concur_req| экземпляров сопрограммы \verb*|get_flags| \cite[\strbook{734}]{ramalho:python-2022}.

С помощью \verb|await| нужно ждать завершения сопрограмм и других объектов, допускающих ожидание, например экземпляров класса \verb*|asyncio.Task| \cite[\strbook{738}]{ramalho:python-2022}.

В Python \emph{чтение и запись} в асинхронном приложении в систему хранения \emph{в главном потоке} \emph{\color{red}блокирует} цикл обработки событий \cite[\strbook{739}]{ramalho:python-2022}.

Сопрограмма \verb|asyncio.to_thread| была добавлена в Python 3.9. Если необходимо поддерживать версии 3.7 или 3.8, то эту строку можно заменить следующими строками \cite[\strbook{739}]{ramalho:python-2022}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
loop = asyncio.get_running_loop()  # получить ссылку на цикл событий
loop.run_in_executor(
    None,  # исполнитель; по умолчанию экзмепляр ThreadPoolExecutor
    save_fig,
    image,
    f"{cc}.gif"
)
\end{lstlisting}

Использование \verb*|run_in_executor| может приводить к трудным для отладки проблемам, потому что отмена не всегда работает, как ожидается. Сопрограммы, в которых используются исполнители, только делают вид, что отменились: для стоящего за ними потока (если это \verb|ThreadPoolExecutor|) нет никакого механизма отмены.

\subsection{Асинхронные итераторы и итерируемые объекты}

\verb*|async for| работает с \emph{асинхронными итерируемыми объектами}, то есть объектами, реализующими метод \verb|__aiter__|. Однако \verb*|__aiter__| должен быть обычными методом, а не сопрограммой, и возвращать \emph{асинхронный итератор}.

Асинхронный итератор предоставляет метод-сопрограмму \verb|__anext__|, который возвращает допускающий ожидание объект, чаще всего объект сопрограммы. Ожидается также, что он реализует метод \verb*|__aiter__|, который обычно возвращает \verb|self|. 

\subsection{Асинхронные генераторные функции}

Для реализации асинхронного итератора нужно написать класс с методами \verb*|__anext__| и \verb|__aiter__|, но есть способ проще: написать функцию, объявленную как \verb*|async def| и содержащую в теле \verb|yield|. 

\section{Метапрограммирование}

Интерпретатор вызывает специальный метод \verb*|__getattr__|, только если обычный поиск атрибута завершается неудачно (то есть именованный атрибут не удается найти ни в экземпляре, ни в классе, ни в его суперклассах) \cite[\strbook{776}]{ramalho:python-2022}.

В Python метод \verb|__init__| получает \verb*|self| в качестве первого аргумента, поэтому к моменту вызова \verb|__init__| интерпретатором объект уже существует. Кроме того, \verb*|__init__| не может ничего возвращать, так что в действительности это \emph{инициализатор}, а \emph{не конструктор} \cite[\strbook{779}]{ramalho:python-2022}. 

Когда класс вызывается для создания экземпляра, Python вызывает специальный метод класса \verb|__new__|. Хотя это метод класса, обрабатывается он не так, как другие: к нему не применяется декоратор \verb*|@classmethod|. Python принимает экземпляр, возвращенный \verb|__new__|, и передает его в качестве первого аргумента \verb*|self| методу \verb|__init__|. 

Чтение или запись напрямую в атрибут объекта \verb*|__dict__| является общепринятой практикой метапрограммирования в Python.

{\color{red}
Создание атрибута \emph{после инициализации экземпляра \underline{отменяет оптимизацию}}, описанную в документе PEP 412 <<Key-Sharing Dictionary>>. В зависимости от размера набора данных разница в потреблении памяти может оказаться существенной
}

Пример самодельного кеширования, не противоречащего оптимизации разделения ключей \cite[\strbook{789}]{ramalho:python-2022}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Event(Record):
    def __init__(self, **kwargs):
        self.__speaker_objs = None  # NB! Атрибут экземпляра создается здесь
        super().__init__(**kwargs)
        
    @property
    def speakers(self):
        if self.__speakers_objs is None:
            spkr_serials = self.__dict__["speakers"]
            fetch = self.__class__.fetch
            # А здесь атрибут экземпляра перепривязывается
            self.__speakers_objs = [fetch(f"speaker.{key}") for key in spkr_serials]
        return self.__speaker_objs
\end{lstlisting}

Однако в многопоточных программах подобные самодельные кеши приводят к состоянию гонки и потенициальному повреждению данных.

{\color{red}NB: \emph{свойство маскирует} атрибут экземпляра с тем же именем! \cite[\strbook{790}]{ramalho:python-2022}}

Декоратор \verb|@cached_peroperty| не создает полноценного свойства, он создает \emph{непереопределяющий дескриптор}. Дескриптор -- объект, который управляет доступом к атрибуту в другом классе.

К слову, \verb*|property| -- это высокоуровневый API для создания \emph{переопределяющего дексриптора}.

Декоратор \verb|@cached_property| имеет несколько важных ограничений \cite[\strbook{790}]{ramalho:python-2022}:
\begin{itemize}
	\item его нельзя использовать в качестве замены \verb*|@property|, если декорируемый метод уже зависит от существования одноименного атрибута экземпляра,
	
	\item его нельзя использовать в классе, где определен атрибут \verb|__slots__|,
	
	\item он \emph{подавляет оптимизацию} разделения ключей в экземпляре \verb*|__dict__|, потому что создает атрибут экземпляра \emph{после} \verb|__init__|.
\end{itemize}

В документации по \verb*|@cached_property| рекомендуется альтернативное решение, которое можно применить к методу \verb|speakers|: образовать композицию декораторов \verb*|@property| и \verb|@cache|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Порядок важен!
@property
@cache
def speakers(self):
    spkr_serials = self.__dict__["speakers"]
    fetch = self.__class__.fetch
    return [fetch(f"speakers.{key}") for key in spkr_serials]
\end{lstlisting}

Сущесвтует два способа абстрагировать определение свойств \cite[\strbook{793}]{ramalho:python-2022}:
\begin{itemize}
	\item фабрика свойств,
	
	\item дескрипторный класс.
\end{itemize}

Встроенная функция \verb*|property| часто используется как декоратор, но в действительности она является классом. В Python функции и классы нередко взаимозаменяемы, поскольку являются вызываемыми объектами и не существует опереатора \verb|new| для создания объекта, поэтому вызов конструктора ничем не отличается от вызова фабричной функции. Как функцию, так и класс можно использовать в качестве декоратора, при условии что они возвращают новый вызываемый объект, являющийся подходящей заменой декорированной функции.

\emph{Свойства} \underline{всегда} являются \emph{атрибутами класса}, но на самом деле они управляют доступом к \emph{атрибутам в экземплярах} этого класса.

При вычислении выражения вида \verb*|obj.data| поиска \verb|data| начинается с класса, а не с экземпляра класса \cite[\strbook{797}]{ramalho:python-2022}.

Следует считать, что \emph{специальные методы ищутся в самом классе}, даже если вызываются от имени экземпляра. По этой причине специальные методы не маскируются одноименными атрибутами экземпляра \cite[\strbook{804}]{ramalho:python-2022}.

Метод \verb*|__getattr__| всегда вызывается после \verb|__getattribute__| и только в том случае, когда \verb*|__getattribute__| возбуждает исключение \verb|AttributeError| \cite[\strbook{805}]{ramalho:python-2022}.

\subsection{Дескрипторы атрибутов}

Дескипторы -- это класс, который реализует динамический протокол, содержащий методы \verb*|__get__|, \verb|__set__| и \verb*|__delete__|. 

Класс \verb|property| реализует весь протокол дескриптора. Как обычно, разрешается реализовать протокол частично. На самом деле большинство дескприторов, встречающихся в реальных программах, реализуют только методы \verb*|__get__| и \verb*|__set__|, а многие -- и вовсе лишь один из них. Пользовательские функции -- это дескрипторы.

Класс, в котором реализован хотя бы один из методов \verb|__get__|, \verb*|__set__| или \verb|_delete__|, является дескриптором. Для использования дескриптора мы объявляем его экземпляры как артибуты класса какого-то другого класса \cite[\strbook{811}]{ramalho:python-2022}.

Для поддержки интроспекции и других приемов метапрограммирования пользователям рекомендуется возвращать из \verb|__get__| экземпляр дескриптора, если доступ к управляемому атрибуту производится через класс. Пример \cite[\strbook{814}]{ramalho:python-2022}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def __get__(self, instance, owner):
    if instance is None:
        return self
    else:
        return instance.__dict__[self.storage_name]
\end{lstlisting}

В методе \verb*|__set__| \verb|self| -- это экземпляр дескриптора, а \verb*|instance| -- это экземпляр управляемого класса.

Чтобы не набирать повторно имя атрибута в объявлении дескриптора, мы реализуем специальный метод \verb|__set_name__|, который будет устанавливать атрибут в каждом экземпляре дескриптора. Этот метод был добавлен в протокол дескприпторов в версии Python 3.6.

Интерпретатор вызывает \verb*|__set_name__| для каждого дескриптора, который находит в теле управляемого класса, -- если дескпритор реализует его. Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Quantity:
    """
    Дескрипторный класс
    """
    def __set_name__(self, owner, name):
        self.storage_name = name
    
    def __set__(self, instance, value):
        if value > 0:
            instance.__dict__[self.storage_name] = value
        else:
            msg = f"{self.storage_name} must be > 0"
            raise ValueError(msg)
            
    # def __get__ # Не нужен
    
class LineItem:
    """
    Управляемый класс
    """
    weight = Quantity()
    price = Quantity()
    
    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price
        
    def subtotal(self):
        return self.weight * self.price
\end{lstlisting}

\verb|self| -- экземпляр дескриптора, \verb*|owner| -- управляемый класс, а \verb|name| -- имя атрибута \verb*|owner|. 

Реализовывать метод \verb|__get__| необязательно, потому что имя \emph{атрибута хранения} совпадает с именем \emph{управляемого атрибута}. Выражение \verb*|product.price| получает атрибут \verb|price| непосредственно из экземпляра \verb*|LineItem|.

Обычно мы не определяем дескриптор в том же модуле, в каком он используется, а заводим отдельный служебный модуль, предназначенный для использования во всем приложении, а то и во многих приложениях, если разрабатывается библиотека или каркас.

Паттерн \emph{самоделегирования} (чаще его называют \emph{паттерном Шаблонный метод})
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import abc

class Validated(abc.ABC):
    def __set_name__(self, owner, name):
        self.storage_name = name
        
    def __set__(self, instance, value):
        value = self.validate(self.storage_name, value)
        instance.__dict__[self.storage_name] = value
        
    @abc.abstractmethod
    def validate(self, name, value):
        """Вернуть проверенное значение или возбудить ValueError"""
\end{lstlisting}

Метод \verb|__set__| делегирует проверку методу \verb*|validate|, который нужно переопределить в подклассе.

Пишем конкретные подклассы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Quantity(Validated):
    """Число, большее нуля"""
    def validate(self, name, value):
        if value <= 0:
            raise ValueError(f"{name} must be > 0")
        return value
        
class NonBlank(Validated):
    """Строка, содержащая хотя бы один символ, отличный от пробела"""
    def validate(self, name, value):
        value = value.strip()
        if not value:
            raise ValueError("f"{name} cannot be blank")
        return value
\end{lstlisting}

Если требуется задействовать не только целевой атрибут, значение которого валидируется, но в том числе и прочие атрибуты, то можно делать так

\begin{lstlisting}[
style = ironpython,
numbers = none
]
class ConsistencyValidator:
	"""Checks consistency for 'problem' and 'params' attrs"""
	def __set_name__(self, owner, name):
		self.storage_name = name

	def __set__(self, instance, value):
		if self.storage_name == "problem":
			_values = ("problem", value, "path_to_problem", instance.path_to_problem)

			if (value is not None) and (instance.path_to_problem is not None):
				raise ValueError(ERROR_CHOOSE_ONE_THING_MSG.format(*_values))
			elif (value is None) and (instance.path_to_problem is None):
				raise ValueError(ERROR_SET_EITHER_MSG.format(*_values))
		elif self.storage_name == "params":
			_values = ("params", value, "path_to_params", instance.path_to_params)

			if (value is not None) and (instance.path_to_params is not None):
				raise ValueError(ERROR_CHOOSE_ONE_THING_MSG.format(*_values))
			elif (value is None) and (instance.path_to_params is None):
				raise ValueError(ERROR_SET_EITHER_MSG.format(*_values))
		else:
			raise ValueError(
				"Error! this validator only makes sense "
				"for the 'problem' and 'params' parameters"
			)

instance.__dict__[self.storage_name] = value
\end{lstlisting}

Или так, в более компактной форме
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class ConsistencyValidator:
	"""Checks consistency for 'problem' and 'params' attrs"""

	def __set_name__(self, owner, name):
		self.storage_name = name

	def __set__(self, instance, value):
		if self.storage_name in {"problem", "params"}:
			_attr_name = self.storage_name
			_attr_path_name = f"path_to_{_attr_name}"
			_record = (
				_attr_name,
				value,
				_attr_path_name,
				operator.attrgetter(_attr_path_name)(instance),
			)
		else:
			raise ValueError(
				f"Error! Validator {type(self).__name__!r} only makes sense "
				"for the 'problem' and 'params' attributes. "
				f"And you're trying to apply it to an attribute: {self.storage_name!r}"
		)

		if (value is not None) and (_record[-1] is not None):
			raise ValueError(ERROR_CHOOSE_ONE_THING_MSG.format(*_record))
		elif (value is None) and (_record[-1] is None):
			raise ValueError(ERROR_SET_EITHER_MSG.format(*_record))

		instance.__dict__[self.storage_name] = value
\end{lstlisting}

В Python существует важная асимметрия. \emph{При чтении} атрибута через экземпляр обычно возвращается атрибут, определенный в этом экземпляре, а если такого атрибута в экземпляре не существует, то атрибут класса. С другой стороны, в случае \emph{присваивания} атрибуту экземпляра обычно создается атрибут в этом экземпляре, а класс вообще никак не задействуется.

Эта асимметрия распространяется и на дескрипторы, в результате чего образуются две категории дескрипторов, различающиеся наличием или отсутствием метода \verb|__set__|. Если \verb*|__set__| присутствует, то класс является \emph{переопределяющим дескриптором}, а иначе \emph{непереопределяющим} \cite[\strbook{820}]{ramalho:python-2022}.

\subsection{Переопределяющие и непереопределяющие дескрипторы}

Дескриптор, в котором реализован метод \verb|__set__|, называется \emph{переопределяющим}, потому что, несмотря на то что этот дескриптор является \emph{атрибутом класса}, он перехватывает все попытки присвоить значение \emph{атрибутам экземпляра}.

Свойства также являются переопределяющими дескрипторами: если мы не предоставим свою функцию установки, то по умолчанию будет использован метод \verb*|__set__| из класса \verb|property|, который возбуждает исключение \verb*|AttributeError|, показывающее, что атрибут можно \emph{только читать} \cite[\strbook{822}]{ramalho:python-2022}.

Дескрипторные атрибуты можно затереть путем присваивания на уровне класса \cite[\strbook{825}]{ramalho:python-2022}.

\emph{Методы} являются \emph{непереопределяющими дескрипторами}, так как не реализован метод \verb|__set__|. И вообще \emph{любая функция} является \emph{непереопределяющим дескриптором} \cite[\strbook{827}]{ramalho:python-2022}.

\subsection{Советы по использованию дескрипторов}

\begin{itemize}
	\item Встроенный класс \verb*|property| создает \emph{переопределяющие дескрипторы}, в которых реализованы оба метода \verb|__set__| и \verb*|__get__|, даже если вы сами не задавали метод установки.
	
	\item Если вы используете дескрипторный класс для реализации атрибута, допускающего \emph{только чтение}, то не забывайте реализовать \emph{оба метода} \verb|__get__| и \verb*|__set__|, иначе одноименный атрибут экземпляра замаскирует дескриптор. Метод \verb|__set__| атрибута, доступного \emph{только для чтения}, должен \emph{просто возбуждать исключение} \verb*|AttributeError| с подходящим сообщением.
	
	\item Если дескриптор предназначен только для проверки значений, то метод \verb|__set__| должен проверять полученный аргумент \verb*|value| и, если он правилен, устанавливать значение непосредственно в атрибуте \verb|__dict__| экземпляра, используя в качестве ключа имя экземпляра дескриптора. Тогда чтение атрибута с таким же именем из экземпляра будет производиться максимально быстро, так как не требует наличия метода \verb*|__get__|.
	
	\item Если написать только метод \verb|__get__|, то получится \emph{непереопределяющий дескриптор}. Они полезны, когда требуется выполнить накладные вычисления и кешировать результат, установив атрибут экземпляра с таким же именем\footnote{Однако, создание атрибутов экземпляра после выполнения метода \texttt{\_\_init\_\_} отключает оптимизацию разделения ключей}.
	
	\item Неспециальные методы можно замаскировать атрибутами экземпляря, однако на специальные методы это не распространяется. {\color{blue}\emph{Специальные} методы интерпретатор ищет \emph{только в самом классе}}, то есть \verb*|repr(x)| всегда вычисляется как \verb|x.__class__.__repr__(x)|.
\end{itemize}

Еще раз, \verb*|property| -- это \emph{переопределяющий} дескпритор (есть метод \verb|__set__|, который возбуждает исключение \verb*|AttributeError|), а вот \verb|@functools.cached_property| порождает \emph{непереопределяющий} дескриптор.

\subsection{Основы метаклассов}

Метакласс -- фабрика классов. Иными словами, \emph{метакласс} -- это класс, \emph{экземплярами} которого являются \emph{классы} \cite[\strbook{854}]{ramalho:python-2022}.

В объектной модели Python \emph{классы} являются \emph{объектами}, поэтому каждый класс должен быть экземпляром какого-то другого класса. По умолчанию классы Python являются \emph{экземплярами} класса \verb*|type|. Иными словами, \verb|type| -- метакласс для большинства встроенных и пользовательских классов.

Любой класс является экземпляром \verb*|type|, прямо или косвенно, но только метаклассы являюется также подклассами \verb|type| \cite[\strbook{856}]{ramalho:python-2022}.

Например, и \verb*|object| и \verb|ABCMeta| -- экземпляры \verb*|type|, но \verb|ABCMeta| -- еще и подкласс метакласса \verb*|type|, поскольку \verb|ABCMeta| является метаклассом.






\section{Замечание о пользовательских пакетах}

При написании пользовательских пакетах файл зависимостей должен быть как можно менее ограничительным
\begin{lstlisting}[
title = {\sffamily requirements.txt},
style = ironpython,
numbers = none
]
# Data
numpy >= 1.16.0, !=1.24.0
pandas >= 1.1.0, < 1.3.0; python_version == '3.7'
pandas >= 1.3.0; python_version >= '3.8'
scipy >= 1.9.3; python_version >= '3.8'

# Parallelization
joblib >= 1.2.0; python_version >= '3.8'

# Models and frameworks
scikit-learn >= 1.0.0; python_version >= '3.8'
pyod >= 1.0.7; python_version >= '3.8'

# Optimization and solvers
# pyomo >= 6.4.2; python_version >= '3.8'
# PySCIPOpt installed using environment.yaml file of conda package manager
pyscipopt >= 4.3.0; python_version == '3.8'

# Plotting
matplotlib >= 3.3.1; python_version >= '3.8'

# Misc
pathlib2 >= 2.3.7
python-dotenv >= 0.21.0
pyyaml >= 6.0
tqdm
psutil >= 5.7.3

# Tests
pytest >= 6.2.0
\end{lstlisting}

Файл \verb|setup.py| может выглядеть так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
rom pathlib import Path
from typing import List

import setuptools

# The directory containing this file
HERE = Path(__file__).parent.resolve()

# The text of the README file
NAME = "zyopt"
VERSION = "0.0.1"
AUTHOR = "Digital Industrial Platform"
SHORT_DESCRIPTION = (
	"Add-in for the SCIP solver with support for heuristics, "
	"classical machine learning and deep learning methods"
)
README = Path(HERE, "README.md").read_text(encoding="utf-8")
URL = ""
REQUIRES_PYTHON = ">=3.8"
LICENSE = "BSD 3-Clause"


def _readlines(*names: str, **kwargs) -> List[str]:
	encoding = kwargs.get("encoding", "utf-8")
	lines = Path(__file__).parent.joinpath(*names).read_text(encoding=encoding).splitlines()
	return list(map(str.strip, lines))


def _extract_requirements(file_name: str):
	return [line for line in _readlines(file_name) if line and not line.startswith("#")]


def _get_requirements(req_name: str):
	requirements = _extract_requirements(req_name)
	return requirements


setuptools.setup(
	name=NAME,
	version=VERSION,
	author=AUTHOR,
	author_email="itmo.nss.team@gmail.com",
	description=SHORT_DESCRIPTION,
	long_description=README,
	long_description_content_type="text/x-rst",
	url=URL,
	python_requires=REQUIRES_PYTHON,
	license=LICENSE,
	packages=setuptools.find_packages(exclude=["test*"]),
	include_package_data=True,
	install_requires=_get_requirements("requirements.txt"),
	classifiers=[
		"License :: OSI Approved :: BSD License",
		"Programming Language :: Python :: 3.8",
		"Programming Language :: Python :: 3.9",
		"Programming Language :: Python :: 3.10",
	],
)
\end{lstlisting}

Сборка выполняется в корне проекта
\begin{lstlisting}[
style = bash,
numbers = none
]
$ python setup.py sdist bdist_wheel
\end{lstlisting}

Если все прошло успешно, то теперь можно опубликовать пакет на TestPyPI с помощью утилиты \verb|twine|
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
$ twine upload -r testpypi dist/* --verbose
\end{lstlisting}

Посмотреть, что получилось можно на \verb|https://test.pypi.org/project/my_prjoect_name/|. Для проверки работоспособности пакета нужно его поставить на локальную машину
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pip install --index-url https://test.pypi.org/simple/ \
    --extra-index-url https://pypi.org/simple my_package_name
\end{lstlisting}

ВАЖНО! Флаг \verb|--extra-index-url| нужен, чтобы \verb|pip| мог при установке извлекать зависимости с PyPI.

И, наконец, если все устраивает, то можно опубликовать пакет на PyPI
\begin{lstlisting}[
style = bash,
numbers = none
]
$ twine upload dist/*
\end{lstlisting}


\section{Инвариантность, ковариантность и контрвариантность}

Обобщенный класс с ковариантным параметром типа
\begin{lstlisting}[
style = ironpython,
numbers = none
]
T_co = TypeVar("T_co", covariant=True)

class BeverageDispenser(Generic[T_co]):
    def __init__(self, beverage: T_co) _> None:
        self.beverage = beverage
    
    def dispense(self) -> T_co:
        return self.beverage
          
def install(dispenser: BeverageDispenser[Juice]) -> None:
    """..."""
\end{lstlisting}

По соглашению суффикс \verb*|_co| в typeshed обозначает ковариантные параметры-типы.

\emph{Ковариантность}: связь тип-подтип между параметризованными классами изменяется в том же направлении, что и связь тип-подтип между параметрами-типами \cite[\strbook{516}]{ramalho:python-2022}.

Пример на контравариантность 
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from typing import TypeVar, Generic

class Refuse:
    """..."""
    
class Biodegradable(Refuse):
    "'''..."""
    
class Compostable(Biodegradable):
    """..."""

T_contra = TypeVar("T_contra", contravariant=True)

class TrashCan(Generic[T_contra]):
    def put(self, refuse: T_contra) -> None:
        """..."""
        
def deploy(trash_can: TrashCan[Biodegradable]):
    """..."""
\end{lstlisting}

\verb|T_contra| -- принятое по соглашению имя котравариантной переменной-типа.

\subsection{Обзор инваринтности}

\subsubsection{Инвариантные типы}

Обобщенный тип \verb*|L| \emph{инвариантен}, если между двумя параметризованными типами нет отношения тип-подтип, даже если такое отношение существует между фактическими параметрами. Иными словами, если \verb|L| инвариантен, то \verb*|L[A]| не является не подтипом, ни супертипом \verb|L[B]|. Они \emph{несовместимы} в обоих направлениях.

\emph{Изменяемые} типы в Python по умолчанию инваринтны. Например, \verb*|list[int]| не совместим с \verb|list[float]|, и наоборот.

В общем случае, если формальный параметр-тип встречается в аннотациях типов аргументов метода и тот же параметр встречается в типе возвращаемого методом значения, то параметр должен быть \emph{инваринтен}, чтобы гарантировать \emph{типобезопасность} при \emph{обновлении} коллекции и \emph{чтении} из нее \cite[\strbook{518}]{ramalho:python-2022}.

\subsubsection{Ковариантные типы}

Некоторые авторы используют символы \verb*|<:| и \verb|:>|, чтобы обозначить следующие отношения: \verb|A :> B| означает, что \verb|A| является супертипом \verb*|B|.

Если \verb|A :> B|, то обобщенный тип \verb*|C| ковариантен, когда \verb|C[A] :> C[B]|. Направление символа \verb*|:>| одинаково в обоих случаях, когда \verb|A| встречается слева от \verb*|B|. Ковариантные обобщенные типы повторяют отношение тип-подтип между фактическими параметрами-типами.

Например
\begin{lstlisting}[
style = ironpython,
numbers = none
]
           float :> int
frozenset[float] :> frozenset[int]
\end{lstlisting}

Любой код, ожидающий итератор \verb|abc.Iterator[float]|, который отдает числа с плавающей точкой, может безопасно использовать итератор \verb*|abc.Iterator[int]|, отдающий целые числа. По той же причине типы \verb|Callable| ковариантны относительно типа возвращаемого значения \cite[\strbook{519}]{ramalho:python-2022}.

\subsection{Контравариантные типы}

Если \verb|A :> B|, то обобщенный тип \verb|K| контравариантен, если \verb*|K[A] <: K[B]|. Контравариантные обобщенные типы обращают связь тип-подтип между фактическими параметрами-типами.

Пример может служить класс \verb*|TrashCan|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
          Refuse :> Biodegradable
TrashCan[Refuse] <: TrashCan[Biodegradable] 
\end{lstlisting}

Контравариантный контейнер обычно представляет собой структуру данных, предназначенную только для записи и называемую <<стоком>>. В стандартной библиотеке нет таких коллекций, но есть несколько типов с контравариантным параметрами-типами.

Тип \verb|Callable[[ParamType, ...], ReturnType]| контравариантен относительно параметров-типов, но ковариантен относительно \verb|ReturnType| \cite[\strbook{519}]{ramalho:python-2022}. Главное то, что \emph{контравариантные} формальные параметры определяют \emph{типы аргументов}, используемых для вызова или отправки данных объекту, тогда как \emph{ковариантные} формальные параметры определяют \emph{типы выходов}, порождаемых объектов, -- тип отдаваемого или возвращаемого значения, в зависимости от объекта.

\subsubsection{Эврестические правила вариантности}

Несколько эврестических правил \cite[\strbook{520}]{ramalho:python-2022}:

\begin{itemize}
	\item Если формальный параметр-тип определяет тип данных, \emph{исходящих} из объекта, то он может быть \emph{ковариантным}.
	
	\item Если формальный параметр-тип определяет тип данных, \emph{входящих} в объект после его начального конструирования, то он может быть \emph{контравариантным}.
	
	\item Если формальный параметр-тип определяет тип данных, \emph{исходящих} из объекта, и тот же параметр определяет тип данных, \emph{входящих} в объект, то он должен быть \emph{инвариантным}.
	
	\item Чтобы ненароком не допустить ошибку, делайте формальные параметры инвариантными.
\end{itemize}

Тип \verb|Callable[[ParamType, ...], ReturnType]|: \verb|ReturnType| \emph{ковариантный}, а каждый \verb|ParamType| \emph{контравариантный} \cite[\strbook{520}]{ramalho:python-2022}. По умолчанию \verb|TypeVar| создает инвариантные формальные параметры, и именно так аннотированы изменяемые коллекции в стандартной библиотеке.

Пример обобщенного типа с ковариантным формальным параметром-типом
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from typing import Protocol, runtime_checkable, TypeVar

T_co = TypeVar("T_co", covariant=True)

@runtime_checkable
class RandomPicker(Protocol[T_co]):
    def pick(self) -> T_co:
        ...
\end{lstlisting}

Обощенный протокол \verb*|RandomPicker| может быть ковариантным, потому что его единственный формальный параметр встречается в \emph{типе возвращаемого значения}.










\section{Передача параметров и возвращаемые значения}

В книге Ромальо \cite[\strbook{219}]{ramalho:python-2022} говорится, что в Python единственный способ передачи параметров -- \emph{вызов по соиспользованию} (call by sharing). Вызов по соиспользованию означает, что каждый формальный параметр функции получает \emph{копию ссылки} на фактический аргумент. {\color{blue}Иначе говоря, внутри функции \emph{параметры} становятся \emph{псевдонимами} фактических аргументов}.

Параметры функции, которые передаются ей при вызове, являются \emph{обычными именами}, ссылающимися на \emph{входные объекты}. {\color{blue}Семантика передачи параметров в языке Python не имеет точного соответствия какому-либо одному способу, такому как <<\emph{передача по значению}>> или <<\emph{передача по ссылке}>>}. Например, если функции передается \emph{неизменяемое} значение, это выглядит, как передача аргумента \emph{по значению}. Однако при передачи \emph{изменяемого} объекта (такого как список или словарь), который модифицируется функцией, эти изменения \emph{будут отражаться на исходном объекте} \cite[\strbook{133}]{beazley:python-2010}.

\section{Значения по умолчанию изменяемого типа: неудачная мысль}

Не следует использовать в качестве значений по умолчанию изменяемые объекты. Проблема в том. что все экземпляры \verb*|HauntBus|, конструктору которых не был явно передан список пассажиров, разделяют один и тот же список по умолчанию. 

Беда в том, что любое значение по умолчанию вычисляется один раз в момент определения функции, то есть обычно на этапе загрузки модуля, после чего значения по умолчанию становятся атрибутами объекта-функции. Так что если значение по умолчанию -- изменяемый объект и вы его изменили, то изменение отразится и на всех последующих вызовах.


\section{Сопоставление с последовательностями-образцами}

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
metro_areas: t.List[t.Tuple[str, str, float, t.Tuple[float, float]]] = [
    ("Tokyo", "JP", 36.933, (35.689, 139.693)),
    ("Delhi NCR", "IN", 21.935, (28.61, 77.21)),
    ...
]

def main():
    for record in metro_areas:
        match record:  # record это субьект
            case [name, _, _, (lat, lon)] if lon <= 0:
                print(...)
\end{lstlisting}

Образцы можно сделать более специфичными, добавив информацию о типе
\begin{lstlisting}[
style = ironpython,
numbers = none
]
case [str(name), _, _, (float(lat), float(lon))]:
    ...
\end{lstlisting}

С другой стороны, если мы хотим произвести сопоставление произвольной последовательности-субъекта, начинающейся с \verb|str| и заканчивающейся вложенной последовательностью из двух \verb*|float|, то можно написать
\begin{lstlisting}[
style = ironpython,
numbers = none
]
case [str(name), *_, (float(lat), float(lon))]:
    ...
\end{lstlisting}

\remark{Важное соглашение в Python API: функции и методы, изменяющие объект на месте, должны возвращать \texttt{None}, давая вызывающей стороне понять, что изменился сам объект в противовес созданию нового \cite[\strbook{81}]{ramalho:python-2022}}

\remark{Кратная конкатенация \emph{неизменяемых последовательностей} выполняется {\color{red}неэффективно}, потому что вместо добавления элементов интерпретатор вынужден {\color{red}копировать всю конечную последовательность}, чтобы создать новую с добавленными элементами. Тип \texttt{str} -- исключение из этого правила. Поскольку построение строки с помощью оператора \texttt{+=} в цикле -- весьма распространенная операция, в CPython этот случай \emph{оптимизирован}. Экземпляры \texttt{str} создаются \emph{с запасом памяти}, чтобы при конкатенации не приходилось каждый раз копировать всю строку \cite[\strbook{79}]{ramalho:python-2022}}

\remark{
Большинство функций numpy и scipy написаны на C или C++ и могут задействовать все доступные ядра процессора, так как освобождают глобальную блокировку интерпретатора \cite[\strbook{90}]{ramalho:python-2022}
}

\section{Правила видимости в функциях}

При каждом вызове функции создается новое локальное пространство имен. Это пространство имен представляет локальное окружение, содержащее имена параметров функции, а также имена переменных, которым были присвоины значения в теле функции. Когда возникает необходимость отыскать имя, интерпретатор в первую очередь просматривает локальное пространство имен. Если искомое имя не было найдено, поиск продолжается в глобальном пространстве имен. Глобальным пространством имен для функций всегда является пространство имен модуля, в котором эта функция была определена. Если интерпретатор не найдет искомое имя в глобальном пространстве имен, поиск будет продолжен во встроенном пространстве имен. Если и эта попытка окажется неудачной, будет возбуждено исключение \texttt{NameError}.

В языке Python поддерживается возможность определять вложенные функции. Переменные во вложенных функциях привязаны к лексической области видимости. То есть поиск имени переменной начинается в \emph{локальной области видимости} и затем последовательно продолжается во всех \emph{объемлющих областях видимости} внешних функций, в направлении от внутренних к внешним. Если и в этих пространствах имен искомое имя не будет найдено, поиск будет продолжен в \emph{глобальном}, а затем во \emph{встроенном пространстве имен}, как и прежде.

При обращении к локальной переменной до того, как ей будет присвоено значение, возбуждается исключение \texttt{UnboundLocalError}
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
i = 0

def foo():
    i = i + 1
    print(i)  # UnboundLocalError
\end{lstlisting}

В функции \texttt{foo} переменная \texttt{i} определяется как локальная переменная, потому что внутри функции ей присваивается некоторое значение и отсутствует инструкция \texttt{global}). При этом инструкция присваивания \texttt{i = i + 1} пытается прочитать значение переменной \texttt{i} еще до того, как ей будет присвоено значение. 

Хотя в этом примере существует глобальная переменная \texttt{i}, она не используется для получения значения. Переменные в функциях могут быть \emph{либо локальными}, \emph{либо глобальными} и не могут произвольно изменять область видимости в середине функции. Например, нельзя считать, что переменная \texttt{i} в выражении \texttt{i = i + 1} в предыдущем фрагменте обращается к глобальной переменной \texttt{i}; при этом переменная \texttt{i} в вызове \texttt{print(i)} подразумевает локальную переменную \texttt{i}, созданную в предыдущей инструкции \cite[\strbook{136}]{beazley:python-2010}.

\section{Функции как объекты и замыкания}

\emph{Функции} в языке Python -- \emph{объекты первого класса}. Это означает, что они могут передаваться другим функциям в виде аргументов, сохраняться в структурах данных и возвращаеться функциями в виде результата \cite[\strbook{136}]{beazley:python-2010}.

Когда инструкции, составляющие функцию, упаковываются вместе с окружением, в котором они выполняются, получившийся объект называют \emph{замыканием}. Такое поведение объясняется наличием у каждой функции атрибута \verb|__globals__|, ссылающегося на глобальное пространство имен, в котором функция была определена. Это пространство имен всегда соответсвтует модулю, в котором функция была объявлена \cite[\strbook{137}]{beazley:python-2010}.

Когда функция используется как \underline{вложенная}, в \emph{замыкание} включается все ее окружение, необходимое для работы внутренней функции.

\emph{Замыкание} -- это функция, назовем ее \verb|f|, с расширенной областью видимости, которая охватывает переменные, на которые есть ссылки в теле \verb*|f|, но которые не являются ни глобальными, ни локальными переменными \verb*|f|. Такие переменные должны происходить из \emph{локальной} области видимости \emph{внешней} функции, \emph{объемлющей} \verb*|f|. Не имеет значения, является функция анонимной или нет; важно лишь, что она может обращаться к \emph{неглобальным} переменным, определенным \emph{вне ее тела} \cite[\strbook{307}]{ramalho:python-2022}.

Пример
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def make_averager():
    series = []  # свободная переменная
    
    def averager(new_value):  # функция-замыкание
        series.append(new_value)
        total = sum(series)
        return total / len(series)
    
    return averager
\end{lstlisting}

Внутри \verb*|averager| переменная \verb*|series| является \emph{свободной переменной}. Этот технический термин означает, что переменная не связана в локальной области видимости.

{\color{blue}\emph{Замыкание} \verb*|averager| (вложенная функция)} расширяет область видимости функции, включая в нее привязку \emph{свободной переменной} \verb*|series|.

Замыкание -- функция. которая запоминает привязки свободных переменных, существовашие на момент определения функции, так что их можно использовать впоследствии при вызове функции, когда область видимости, в которой она была определена, уже не существует.

Отметим, что единственная ситуация, когда функции может понадобится доступ к внешним неглобальным переменным, -- это когда она вложена в другую функцию и эти переменные являются частью локальной области видимости внешней функции \cite[\strbook{310}]{ramalho:python-2022}.




\section{Типизация}

Замечательная книга Алексея Голобурдина <<Типизированный Python для профессоинальной разработки>> \url{https://to.digital/typed-python/intro/intro.html}

От типов модуля \texttt{typing} можно наследоваться
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import typing as t
from collection import namedtuple

# Наследуемся от именного кортежа
class Coordinates(t.NamedTuple):
    latit: float
    long: float
    
# Или так
# Но тип поля теперь не указать
# Coordinates = namedtuple("Coordinates", ["latit", "long"])

# Доступ к полям через точечную нотацию
coord = Coordinates(latit=0.45, long=1.45)
coord.latit  # 0.45
coord.long  # 1.45
\end{lstlisting}

Функционально тоже что и дата-класс
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from dataclasses import dataclass

@dataclass(fronzen=False)
class Coordinates:
    latit: float
    long: float
\end{lstlisting}

Именованные кортежы от дата-классов отличаются тем, что именованные кортежи относятся к объектам неизменяемого типа данных. Дата-классы вообще говоря тоже можно сделать неизменяемыми после создания с помощью параметра \verb|frozen=True|.

Именованные кортежи эффективнее с точки зрения хранения. С помощью библиотеки \verb|pympler| \url{https://github.com/pympler/pympler}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import typing as t
from pympler import asizeof

class Coordinates(t.NamedTuple):
    latit: float
    long: float
    
print(asizeof.asized(coord).size)  # 104 Bytes
\end{lstlisting}

Иногда бывает полезно воспользоваться \emph{типизированным словарем} \verb|TypedDict|
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import typing as t

# Доступ к полям будет как у словаря
class Coordinates(t.TypedDict):
    latit: float
    long: float
    
coord = Coordinates(latit=0.45, long=0.15)
coord["latit"]  # 0.45
coord["long"]  # 0.15
\end{lstlisting}

Еще бывает удобно воспользоваться \emph{перечислением} \verb|Enum|. Модуль \verb|enum| это стандартная часть библиотеки Python, но если по какой-то причине интерпретатор не может его найти, то модуль можно установить так \verb|pip insatll enum|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from enum import Enum

# Перечисление
class FileState(Enum):
    OPENED = "opened"
    CLOSE = "close"
    
FileState.OPENED.value  # opened
\end{lstlisting}

Полезные замечания по перечислениям \url{https://realpython.com/python-enum/}. Значения элементов перечисления могут быть числом, строкой или любым другим объектом. Перечисления поддерживают операторы \verb|in| и \verb*|not in|.

Для того чтобы не повторять имена элементов в качестве значений, можно воспользоваться следующим приемом
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from enum import Enum, auto


class SolverStatus(Enum):
    def _generate_next_value_(name, start, count, last_values):
        return name.upper()
    
    OPTIMAL = auto()    
    INFEASIBLE = auto()

SolverStatus.OPTIMAL  # <SolverStatus.OPTIMAL: 'OPTIMAL'>
\end{lstlisting}

Перечисления поддерживают два типа операторов сравнения:
\begin{enumerate}
	\item \verb*|is|, \verb*|is not|,
	
	\item \verb*|==|, \verb*|!=|.
\end{enumerate}

Сравнение элементов двух различных перечислений всегда возвращает \verb*|False|.

В принципе поведение перечисления можно сымитировать с помощью именованного кортежа
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import typing as t

class FileState(t.NamedTuple):
    OPENED = "opened"
    CLOSE = "close"
    
FileState.OPENED  # "opened"
\end{lstlisting}

Для неименованных кортежей можно создавать псевдонимы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Кортеж с произвольным количеством целых чисел
int_tuple = t.Tuple[int, ...]

def f(*args: int_tuple) -> int:
    return sum(args)
    
print(f(10, 20, 30))  # 60

two_ints = t.Tuple[int, int]
# etc.
\end{lstlisting}

Generic (обобщенные типы)
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import typing as t
T = t.TypeVar("T")  # обобщенный тип

def first(iterable: t.Iterable[T]) -> t.Optional[T]:
    for item in iterable:
        return item
\end{lstlisting}


\section{Модули, пакеты и дистрибутивы}

ВАЖНО: \emph{текущим каталогом} (\verb|os.path.curdir|) будет тот, из-под которого запускается сценарий, но сканирование <<окружающего пространства>> в поисках нужных пользовательских модулей и пр. начинается с той директории, в которой \emph{расположен} сценарий (см. \verb|sys.path|). Если требуется какие-то подмодули сделать доступными через пространство имен пакета с помьщю \verb|__init__.py|, то лучше воспользоваться относительным импортом (он более четко указывает о намерениях).

Можно указывать относительный путь, а можно абсолютный, но от той {директории}, в которой лежит пусковой сценарий (например, \verb|./src/run.py|). То есть, если
\begin{lstlisting}[
style = bash,
numbers = none
]
./  # корень проекта
  src/
    config/  # пакет
      __init__.py
      config.py  # модуль
      ...
\end{lstlisting}
то
\begin{lstlisting}[
title = {\sffamily ./src/config/\_\_init\_\_.py},
style = bash,
numbers = none
]
# поиск начнется со сканирования src/ (потому что здесь лежит пакет config/)
from config.config import Config
# или относительно директории пакета
from .config import Config
\end{lstlisting}

ВАЖНО: в общем случае абсолютный путь в модулях \verb|__init__.py| отсчитывается от директории родительского пакета, то есть от той директории, в которой лежит пусковой сценарий. Этот сценарий указывает от какой директории теперь отсчитываться (не включая эту директорию в пути).

Для сценариев командной оболочки можно явно указать директорию, которая должна просматриваться первой в поисках модулей и пакетов с помощью переменной окружения \verb*|PYTHONPATH|
\begin{lstlisting}[
title = {\sffamily ./src/strategy\_templates/make\_strategy\_file.py},
style = ironpython,
numbers = none
]
from strategy_templates.templates import *
...
\end{lstlisting}

\begin{lstlisting}[
style = bash,
numbers = none
]
# Сканироваться будет директория ./src
PYTHONPATH=./src python ./src/strategy_templates/make_strategy_file.py ...
\end{lstlisting}

Пусковой сценарий удобно располагать в поддиректории проекта \verb|./src|. Если запускать сценарий так \verb|python ./src/run.py|, то сканирование начнется с директории \verb|src| и технически все будет верно, но PyCharm будет подсвечивать пути красным. Чтобы убрать эту красноту, нужно просто объявить \verb|./src| как <<Sources Root>>, кликнув правой кнопкой мыши на директории в дереве проекта и выбрав соответсвующую метку.

Когда инструкция \texttt{import} впервые загружает модуль, она выполняет следующие три операции \cite[\strbook{189}]{beazley:python-2010}:
\begin{enumerate}
	\item Создает новое пространство имен, которое будет служить контейнером для всех объектов, определенных в соответствующем файле.
	
	\item Выполняет программный код в модуле внутри вновь созданного пространства имен.
	
	\item Создает в вызывающей программе имя, ссылающееся на пространство имен модуля. Это имя совпадает с именем модуля.
\end{enumerate}

Когда модуль импортируется впервые, он компилируется в байт-код и сохраняется на диске в файле с расширением \texttt{*.pyc}. При всех последующих обращениях к импортированию этого модуля интепретатор будет загружать скомпилированный байт-код, если только с момента создания байт-кода в файл \texttt{.py} не вносились изменения (в этом случае файл \texttt{.pyc} будет создан заново).

Автоматическая компиляция программного кода в файл с расширением \texttt{.pyc} производиться только при использовании инструкции \texttt{import}. При запуске программ из командной строки этот файл не создается.

\emph{Модули} в языке Python -- это \emph{объекты первого класса} \cite[\strbook{190}]{beazley:python-2010}. То есть они могут присваиваться переменным, помещаться в структуры данных, такие как списки, и передаваться между частями программы в виде элемента данных. Например
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import pandas as pd
\end{lstlisting}
просто создает переменную \texttt{pd}, которая ссылается на объект модуля \texttt{pandas}.

Важно подчеркнуть, что инструкция \texttt{import} выполнит все инструкции в загруженном файле. Если в дополнение к объявлению переменных, функций и классов в модуле содержаться некоторые вычисления и вывод результатов, то результаты будут выведены на экран в момент загрузки модуля.

Инструкция \texttt{import} может появляться в любом месте программы. Однако программный код любого модуля \emph{загружается} и \emph{выполняется} только один раз, независимо от количества инструкций \texttt{import}. 

\emph{Глобальным пространством имен} для функции всегда будет \emph{модуль}, в котором она была \underline{объявлена}, а не пространство имен, в которое эта функция была импортирована и откуда была вызвана \cite[\strbook{192}]{beazley:python-2010}.

Пакеты позволяют сгруппировать коллекцию модулей под общим именем пакета. Пакет создается как каталог с тем же именем, в котором создается файл с именем \verb|__init__.py|.

Например, пакет может иметь такую структуру
\begin{lstlisting}[
style = bash,
numbers = none
]
graphics/
    __init__.py
    primitives/
        __init__.py
        lines.py
        fill.py
        text.py
        ...
    graph2d/
        __init__.py
        plot2d.py
        ...
    graph3d/
        plot3d.py
        ...
    formats/
        __init__.py
        gif.py
        png.py
        tiff.py
        ...
\end{lstlisting}

Всякий раз когда какая-либо \emph{часть пакета импортируется впервые}, выполняется программный код в файле \verb|__init__.py| \cite[\strbook{198}]{beazley:python-2010}. Этот файл может быть пустым, но может также содержать программный код, выполняющий инициализацию пакета. Выполнены будут все файлы \verb|__init__.py|, которые встретятся инструкции \texttt{import} в процессе ее выполнения.

То есть инструкция
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import graphics.primitives.fill
\end{lstlisting}
сначала выполнит файл \verb|__init__.py| в каталоге \texttt{graphics}, а затем файл \verb|__init__.py| в каталоге \texttt{primitives}.

При импортировании модулей из пакета следует быть особенно внимательными и не использовать инструкцию вида \texttt{import module}, так как в Python 3, инструкция \texttt{import} предполагает, что указан абсолютный путь, и будет пытаться загрузить модуль из стандартной библиотеки. Использование инструкции импортирования по относительному пути более четко говорит о ваших намерениях.

Возможность импортирования по относительному пути можно также использовать для загрузки модулей, находящихся в других каталогах того же пакета. Например, если в модуле \texttt{Graphics.Graph2d.plot2d} потребуется импортировать модуль \texttt{Graphics.Primitives.lines}, инструкция импорта будет иметь следующий вид
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from ..primitives import lines  # так можно!
\end{lstlisting}

В этом примере символы \texttt{..} перемещают точку начала поиска на уровень выше в дереве каталогов, а имя \texttt{primiitves} перемещает ее вниз, в другой каталог пакета.

Импорт по относительному пути может выполняться только при использовании инструкции импортирования вида
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from module import symbol
\end{lstlisting}

То есть такие конструкции, как
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import ..primitives.lines  # Ошибка!
import .lines  # Ошибка!
\end{lstlisting}
будут рассматриваться как синтаксическая ошибка.

Кроме того, имя \texttt{symbol} должно быть допустимым идентификатором. Поэтому такая инструкция, как 
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from .. import primitives.lines  # Ошибка!
\end{lstlisting}
также считается ошибочной.

Наконец, импортирование по относительному пути может выполняться только для модулей в пакете; не допускается использовать эту возможность для ссылки на модули, которые просто находятся в другом каталоге файловой системы.

Импортирование по одному только имени пакета не приводит к импортированию всех модулей, содержащихся в этом пакете \cite[\strbook{199}]{beazley:python-2010}, однако, так как инструкция \texttt{import graphics} выполнит файл \verb|__init__.py| в каталоге \texttt{graphics}, в него можно добавить инструкции импортирования по относительному пути, которые автоматически загрузят все модули, как показано ниже
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# graphics/__init__.py
from . import primitives, graph2d, graph3d

# graphics/primitives/__init__.py
from . import lines, fill, text
...
\end{lstlisting}

Для того чтобы сделать функции модулей подпакетов доступными из-под имени подпакетов (без обращения к модулям, в которых были объявлены эти функции), можно относительный импорт организовать следующим образом
\begin{lstlisting}[
style = ironpython,
numbers =  none
]
# graphics/primitives/__init__.py
from .fill import make_fill
from .lines import make_lines
...
\end{lstlisting}

Теперь вызвать, например, функцию \texttt{make\_fill} модуля \texttt{fill} подпакета \texttt{primitives} можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from graphics.primitives import make_fill
# вместо
from graphics.primitives.fill import make_fill
\end{lstlisting}

Грубо говоря, можно считать, что элементы расположенные справа от инструкции \texttt{import} в файле \verb|__init__.py| будут как бы замещать имя модуля \verb|__init__.py| в пути до этого файла, т.е.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# graphics/formats/__init__.py
from .png import print_png
from .jpg import print_jpg

# В сессии
>>> import graphics.formats.print_png
\end{lstlisting}

Переменная \verb|__all__| управляет логикой работы инструкции \verb|import *| и проявляется только если пользователь модуля/пакета использует прием <<импортировать все>>. Если известен путь до нужного модуля, то переменная \verb|__all__| не помешает. Если определить \verb|__all__| как пустой список, ничего экспортироваться не будет \cite[\strbook{395}]{beazley:python_cookbook-2019}.

Важное замечание: относительное импортирование работает только для модулей, которые размещены внутри подходящего пакета. В частности, оно не работает внутри простых модулей, размещенных на верхнем уровне скриптов. Оно также не работает, если \emph{части пакета} исполняются напрямую, \emph{как скрипты}, например \cite[\strbook{396}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ python mypackage/A/spam.py  # Относительное импортирование не работает!!!
\end{lstlisting}

С другой стороны, если вы выполните предыдущий скрипт, передав Python опцию \verb|-m|, относительное импортирование будет работать правильно
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ python -m mypackage/A/spam  # Относительное импортирование работает!
\end{lstlisting}

\remark{
Относительный импорт не работает, если части пакета исполняются напрямую, как скрипты. Но ситуацияю можно исправить, если воспользоваться опцией \texttt{-m}
}




Наконец, когда интерпретатор импортирует пакет, он объявляет специальную переменную \verb|__path__|, содержащую список каталогов, в которых выполняется поиск модулей пакета (\verb|__path__| представляет собой аналог списка \texttt{sys.path} для пакета). Переменная \verb|__path__| доступна для программного кода в файлах \verb|__init__.py| и изначально содержит единственный элемент с именем каталога пакета.

При необходимости пакет может добавлять в список \verb|__path__| дополнительные каталоги, чтобы изменить путь поиска модулей. Это может потребоваться в случае сложной организации дерева каталогов пакета в файловой системе, которая не совпадает с иерархией пакета.

\subsection{Создание отдельных каталогов с кодом для импорта под общим пространством имен}

Требуется определить пакет Python высшего уровня, который будет служить пространством имен для большой коллекции отдельно поддерживаемых подпакетов.

Нужно организовать код так же, как и в обычном пакете Python, но опустить файлы \verb|__init__.py| в каталогах, где компоненты будут объединяться. Пример \cite[\strbook{399}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
foo-package/
    spam/
        blah.py
        
bar-package/
    spam/
        grok.py
\end{lstlisting}

В этих каталогах имя \texttt{spam} используется в качестве общего пространства имен. Обратите внимание, что файл \verb|__init__.py| отсутствует в обоих каталогах.

Теперь, если добавить оба пакета \texttt{foo-package} и \texttt{bar-package} к пути поиска модулей Python и попробуете импортировать
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import sys
sys.path.extend(["foo-package", "bar-package"])
import spam.blah
import spam.grok
\end{lstlisting}

Для разных каталога пакетов слились вместе. Механизм, который здесь работает, известен под названием <<пакет пространства имен>>. По сути, пакет пространства имен -- это специальный пакет, разработанный для слияния различных каталогов с кодом под общим пространством имен.

Ключ к созданию пакета пространства имен -- отсутствие файлов \verb|__init__.py| в каталоге высшего уровня, который служит общим пространством имен. Вместо того чтобы выкинуть ошибку, интерпретатор начинает создавать список всех каталогов, которые содержит совпадающее имя пакета. Затем создается специальный модуль-пакет пространства имен, и в его переменной \verb|__path__| сохраняется доступная только для чтения копия списка каталогов.





\section{Некоторые приемы}

\subsection{Вычисления со словарями}

Рассмотрим словарь, который отображает тикеры на цены
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d = {
    "ACME": 45.23,
    "AAPL": 612.78,
    "IBM": 205.55,
    "HPQ": 37.20,
    "FB": 10.75,
}
\end{lstlisting}

Чтобы найти наименьшую/наибольшую цены с тикером можно обратить ключи и значения, а затем воспользоваться функций \texttt{zip()}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
min(zip(d.values(), d.keys()))  # (10.75, "FB")
max(zip(d.values(), d.keys()))  # (612.78, "AAPL")
\end{lstlisting}

Важно иметь в виду, что функция \texttt{zip()} создает итератор, по которому можно пройти только один раз.

Использование функции \texttt{zip()} решает задачу путем <<обращения>> словаря в последовательность пар (value, key). 

Однако, вариант с функцией \texttt{zip()} требует большего времени, чем вариант на цикле
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%timeit -n 1_000_000
# 639 ns +/- 3.04 ns per loop (mean +/- std. dev. of 7 runs, 1,000,000 loops each)
min(zip(d.values(), d.values()))  

%%timeit -n 1_000_000
# 576 ns +/- 1.4 ns per loop (mean +/- std. dev. of 7 runs, 1,000,000 loops each)
def find_min_pair(d: t.Dict[str, float]) -> t.Tuple[float, str]:
    min_value = float("inf")
    for key, value in d.items():
        if value < min_value:
            min_value = d[key]
            min_key = key
    return (min_value, min_key)
\end{lstlisting} 

Пусть есть два словаря. Требуется выяснить, что у них общего
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d1 = {"x": 1, "y": 2, "z": 3}
d2 = {"w": 10, "x": 11, "y": 2}

# Найти общие ключи
d1.keys() & d2.keys()

# Находим ключи, которые есть в d1, но которых нет в d2
d1.keys() - d2.keys()

# Находим общие пары (key, value)
d1.items() & d2.items()  # {("y", 2)}
\end{lstlisting}

Словарь -- это отображение множества ключей на мнгожество значений. Метод словаря \texttt{keys()} возвращает \emph{объект ключей словаря} \texttt{dict\_keys}. Малоизвестная особенность этих объектов заключается в том, что они поддерживают набор операций над \emph{множествами}: объединение, пересечение и разность. Так что, если требуется выполнить этот набор операций над ключами словаря, то можно использовать объект ключей словаря напрямую, без предварительного конвертирования во множество \cite[\strbook{35}]{beazley:python_cookbook-2019}, т.е.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
d1.keys() & d2.keys()  # {"x", "y"}
# вместо
set(d1.keys()) & set(d2.keys())  # {"x", "y"}
# или
set(d1.keys()).intersection(set(d2.keys()))  # {"x", "y"}
\end{lstlisting}

Найти пересечение индексов двух серий можно было бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
ser1 = pd.Series(d1, name="ser1")
ser2 = pd.Series(d2, name="ser2")

pd.merge(
    ser1,
    ser2,
    left_index=True,
    right_index=True,
    how="inner"
).index.to_list()  # ["x", "y"]
\end{lstlisting}

Ремарка: в \emph{контейнерных последовательностях} (\verb|list|, \verb*|tuple| etc.) храняться \emph{ссылки} на объекты \underline{любого типа}, тогда как в \emph{плоских последовательностях} (\verb|str|, \verb*|bytes| etc.) -- сами значения прямо в памяти, занятой последовательнсотью, а не как отдельные объекты Python \cite[\strbook{49}]{ramalho:python-2022}.

\subsection{Удаление дубликатов из последовательности}

Вы хотите ислкючить дублирующиеся значения из последовательности, но при этом сохранить порядрк следования оставшихся элементов.

Если значения в последовательности являютеся хешируемыми, задача может быть легко решена с использованием множества и генератора
\begin{lstlisting}[
style = ironpython,
numbers = none
]
%%timeit -n 100_000
# 984 ns +/- 17.6 ns per loop (mean +/- std. dev. of 7 runs, 100,000 loops each)
def dedupe(items: t.Iterable[int]) -> t.Iterable[int]:
    seen: t.Set[int] = set()
    for item in items:
        if item not in seen:
            yield item  # отдать элемент
            seen.add(item)  # обновить множество
            
lst = [1, 5, 2, 1, 9, 1, 5, 10]
list(dedupe(lst))  # [1, 5, 2, 9, 10]
\end{lstlisting}

Или так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
%%timeit -n 100_000
# 663 ns +/- 26.2 ns per loop (mean +/- std. dev. of 7 runs, 100,000 loops each)
def dedupe_list(items: t.Iterable[int]) -> t.Iterable[int]:
    seen: t.Iterable[int] = []
    for item in items:
        if item not in seen:
            seen.append(item)
    return seen
\end{lstlisting}

\subsection{Сортировка списка словарей по общему ключу}

У вас есть список словарей, и вы хотите отсортировать записи согласно одному или более полям. Сортировка структур этого типа легко выполняется с помощью функции \texttt{operator.itemgetter}. Именованный аргумент \texttt{key} должен быть \emph{вызываемым объектом} (т.е. объектом, в котором реализован метод \verb|__call__|). Функция \texttt{itemgetter()} создает такой вызываемый объект
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from operator import itergetter

records: t.Iterable[dict] = [
    {"fname": "Brian", "lname": "Jones", "uid": 1003},
    {"fname": "David", "lname": "Beazley", "uid": 1002},
    {"fname": "John", "lname": "Cleese", "uid": 1004},
]

# аргумент key ожидает получить вызываемый объект
sorted(records, key=itemgetter("fname"))
sorted(records, key=itergetter("uid"))
# то же, что и
sorted(records, key=lambda record: record["fname"])
sorted(records, key=lambda record: record["uid"])
\end{lstlisting}

Функция \texttt{itemgetter()} может принимать несколько полей
\begin{lstlisting}[
style = ironpython,
numbers = none
]
sorted(records, key=itemtegger("lname", "fname"))
\end{lstlisting}

Эту технику можно применять и к функциям \texttt{min}, \texttt{max}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# найти строку с наименьшим значением идентификационного номера
min(records, key=itemgetter("uid"))
\end{lstlisting}

\subsection{Отображение имен на последовательность элементов}

У вас есть код, который осуществляет доступ к элементам в списке или кортеже по позиции. Однако такой подход часто программу нечитабельной. 

\texttt{collections.namedtuple()} -- фабричный метод, который возвращает подкласс стандартного типа Python -- tuple. Метод возвращает класс, который может порождать экземпляры
\begin{lstlisting}[
style = ironpython,
numbers = none
]
Person = namedtuple("Person", ["name", "age", "job"])
leor = Person(name="Leor", age=36, job="DS")
\end{lstlisting}

Хотя экземпляр \texttt{namedtuple} выглядит так же, как и обычный экземпляр класса, он взаимозаменям с кортежем и поддерживает все обычные операции кортежей, такие как индексирование и распаковка
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
name, age, job = leor
\end{lstlisting}

Возможное использование именнованного кортежа -- замена словаря, который требует больше места для хранения. Так что, если создаете крупные структуры данных с использованием словарей, применение именованных кортежей будет более эффективным. Однако, именованные кортежи неизменяемы в отличие от словарей.

Если вам нужно изменить любой из атрибутов, это может быть сделано с помощью метода \verb|_replace()|, которым обладают экземпляры именованных кортежей.

Тонкость использования метода \verb|_replace()| заключается в том, что он может стать удобным способом наполнить значениями именованный кортеж, у которого есть опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип кортежа, содержащий значения по умолчанию, а затем применяйте \verb|_replace()| для создания новых экземпляров с замененными значениями
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from collection import namedtuple

Stock = namedtuple("Stock", ["name", "shares", "price", "date", "time"])
stock_prototype = Stock("", 0, 0.0, None, None)

def dict_to_stock(s):
    return stock_prototype._replace(**s)
\end{lstlisting}

\section{Строки и текст}

\subsection{Разрезание строк различными разделителями}

Нужно разделить строку на поля, но разделители (и пробелы вокруг них) внтури строки разные
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import re
line = "asdf fjdk; afed, fjek,asdf,     foo"
re.split(r"[;,\s]\s*", line)
\end{lstlisting}





\section{Профилирование и замеры времени выполнения}

При проведении измерений производительности нужно помнить, что любые результаты будут приблизительными. Функция \texttt{time.perf\_counter()} предоставляет наиболее точный таймер из доступных. Однако она все-таки измеряет \emph{внешнее время}, и {\color{red}на результаты влияют различные факторы, такие как нагруженность компьютера}.

Если вы хотите получить время обработки, а не внешнее время, используйте \texttt{time.process\_time()} \cite[\strbook{574}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps

def timethis(func):
    @wraps(func)
    def wrapper(*args, **kwrags):
        start = time.process_time()  # <- NB
        r = func(*args, **kwargs)
        stop = time.process_time()  # <- NB
        print(f"{func.__module__}.{func.__name__} : {end - start}")
        return r
    return wrapper
    
@timethis
def countdown(n):
    while n > 0:
        n -= 1

countdown(100000)
\end{lstlisting}

Чтобы подсчитать время выполнения блока инструкций, можно определить менеджер контекста
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from contexlib import contexmanager

@contextmanager
def timeblock(label):
    start = time.process_time()
    try:
       yield
    finally:
        end = time.process_time()
        print(f"{label} : {end - start}")
        
with timeblock("counting"):
	n = 100000
	while n > 0:
	    n -= 1
	# counting: 1.55555
\end{lstlisting}

Запустить профилировщик для веб-приложения и перенаправить вывод профилировщика в файл
\begin{lstlisting}[
style = bash,
numbers = none
]
# В основном терминале
$ python -m cProfile flask_app.py > profile.log
 * Serving Flask app 'solverapi' (lazy loading)
* Environment: production
WARNING: This is a development server. Do not use it in a production deployment.
Use a production WSGI server instead.
* Debug mode: on
* Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
* Restarting with stat
* Debugger is active!
* Debugger PIN: 158-204-808

# В параллельном терминале
$ curl -H "Content-Type: application/json" -X POST --data "@file_name.json" "localhost:5000/api/solver/balance"
# После завершения расчета можно прервать сессию в основном терминале
$ vim profile.log
\end{lstlisting}

Граф цепочки выполнения программы можно построить следующим образом
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pip install gprof2dot
$ python -m cProfile -o profile.pstat app.py
$ gprof2dot -f pstats profile.pstat | dot -Tpng -o output.png
\end{lstlisting}

Потребление памяти приложением можно оценить с помощью библиотеки \texttt{memory\_profiler} \url{https://pypi.org/project/memory-profiler/}. После установки библиотеки будет доступна утилита командной строки \texttt{mprof}.

Запустить приложение в режиме замера потребления памяти для основного (родительского) процесса и его дочерних процессов (если они существуют) можно следующим образом
\begin{lstlisting}[
style = bash,
numbers = none
]
$ mprof run --include-children --multiprocess script.py
\end{lstlisting}

После остановки приложения в рабочей директории будет создан dat-файл с результатами измерений потребления памяти. Построить график потребления можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
# -s: угол наклона, по которому можно судить об утечке памяти
#  -t: заголовок графика
$ mprof plot -s -t "496.lp"
\end{lstlisting}

Перечень поддерживаемых флагов, связанных с конкретной подкомандой \texttt{mprof}, можно просмотреть так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ mprof <subcommand> --help
...
\end{lstlisting}

Для измерения потребления памяти какой-то конкретной функции можно воспользоваться декоратором \texttt{@memory\_profiler.profile}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from memory_profiler import profile

@profile
def my_func():
    a = [1] * (10 ** 6)
    b = [2] * (2 * 10 ** 7)
    del b
    return a
\end{lstlisting}

Затем остается только запустить интерпретатор с флагом \verb|-m memory_profiler| и проанализировать ответ \texttt{memory\_profiler}.


\section{Итераторы и генераторы}

Ремарка: Инициализацию кортежей, массивов и других последовательностей можно начинать с использования спискового включения, но \emph{генераторное выражение} экономит память, так как \emph{отдает элементы по одному}, применяя протокол итератора, вместо того чтобы сразу строить целиком список для передачи другому конструктору \cite[\strbook{55}]{ramalho:python-2022}.

В большинстве случаев для прохода по итериуемому объекту используется цикл \texttt{for}. Однако иногда задачи требуют более точного контроля лежащего в основе механизма итераций. 

Следующий код иллюстрирует базовые механизмы того, что происходит во время итерирования
\begin{lstlisting}[
style = ironpython,
numbers = none
]
items = [1, 2, 3] # Итерируемый объект
# Получаем объект итератора
# Функция iter(items) вызывает метод итерируемого объекта items.__iter__()
it = iter(items) # Итератор
# Запускаем итератор
next(it) # Вызывается it.__next__() -> 1
next(it) # -> 2
next(it) # -> 3
next(it) # Возбуждается исключение StopIteration
\end{lstlisting}

Список \texttt{items} как \emph{итерируемый объект} имеет метод \verb|__iter__()|, который должен возвращать \emph{объект-итератора} (\texttt{it}). У объекта-итератора должен быть метод \verb|__next__()| для перебора элементов. Вот функция \texttt{next(it)} и вызывает метод \verb|__next__()| объекта-итератора для получения следующего элемента. Когда список исчерпывается, возбуждается исключение \texttt{StopIteration}.

\emph{Протокол итераций} Python требует, чтобы метод \verb|__iter__()| возвращал специальный объект-итератор, в котором реализован метод \verb|__next__()|, который выполняет итерацию \cite[\strbook{128}]{beazley:python_cookbook-2019}. Функция \texttt{iter()} просто вовзвращает внутренний итератор, вызывая \verb|s.__iter__()|.

\emph{Протокол итератора} Python требует \verb|__iter__()|, чтобы вернуть специальный \emph{объект итератора}, в котором реализован метод \verb|__next__()|, а исключение \texttt{StopIteration} используется для подачи сигнала о завершении \cite[\strbook{131}]{beazley:python_cookbook-2019}.

Когда поток управления покидает тело генераторной функции, возбуждается исключение \texttt{StopIteration}.

Метод \verb|__iter__()| \emph{итерируемого объекта} может быть реализован как обычная \emph{генераторная функция} \cite[\strbook{133}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class linehistory:
    ...
    def __iter__(self):
        for lineno, line in enumerate(self.lines, 1):
            self.history.append((lineno, line))
            yield line
\end{lstlisting}

Для того чтобы пропустить первые несколько элементов по какому-то условию, можно воспользоваться функцией \texttt{itertools.dropwhile}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from itertools import dropwhile

def read_wo_header(file_name: str):
    with open(file_name, mode="r") as f:
        for line in dropwhile(lambda line: line.startswith("#"), f):
            print(line.rstrip())
\end{lstlisting}

Возвращаемый итератор отбрасывает первые элементы в последовательности до тех пор, пока предоставленная функция возвращает \texttt{True}.

Если нужно просто пропустить первые несколько строк файла (не по условию), то будет полезна функция \texttt{itertools.islice}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
with open(file_name, mode="r", encoding="utf-8") as f:
    for line in islice(f, 7, None):  # пропустить первые 7 строк файла
        if line.startswith("# rows".lower()):
            break
       ...
\end{lstlisting}

\section{Захват переменных в анонимных функциях}

Рассмотрим поведение следующей программы:
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> x = 10
>>> a = lambda y: x + y
>>> x = 20
>>> b = lambda y: x + y
>>> a(10)  # 30
>>> b(10)  # 30
\end{lstlisting}

Проблема в том, что значение \texttt{x}, используемые lambda-выражением, является \emph{свободной переменной}, которая связывается во время \emph{выполнения}, а не во время \emph{определения} \cite[\strbook{233}]{beazley:python_cookbook-2019}. Так что значение \texttt{x} будет таким, каким ему случиться быть во время выполнения.

\remark{
\emph{Свободные переменные} связываются во время \emph{выполнения}, а не во время определения
}

Другими словами у замыканий позднее связывание. Замыкания -- это функции с расширенной областью видимости, которая включает все неглобальные переменные. То есть замыкания умеют запоминать привязки свободных переменных.

Например,
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
funcs = [
    lambda x: x + n
    for n in range(3)
]
for f in funcs:
    print(f(0))
# 2
# 2
# 2
\end{lstlisting}

\section{Передача дополнительного состояния с функциями обратного вызова}

\begin{lstlisting}[
style = ironpython,
numbers = none	
]
import typing as t

def apply_async(
    func: t.Callable,
    args: t.Tuple[t.Union[str, int],
    *,
    callback: t.Callable]
) -> t.NoReturn:
    result: t.Union[str, int] = func(*args)
    callback(result)
    
def add(x: int, y: int) -> int:
    return x + y
\end{lstlisting}

Для хранения состояния можно использовать \emph{замыкание} \cite[\strbook{238}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def make_handler():
    count = 0
    def handler(result: t.Union[str, int]) -> t.NoReturn:
        nonlocal count
        count += 1
        print(f"[{count}] Got: {result}")
    return handler
    
handler = make_handler()
apply_async(add, (2, 3), callback=handler)  # [1] Got: 5
apply_async(add, ("hello", "world"), callback=handler)  # [2] Got: hello world 
\end{lstlisting}

\section{Использование лениво вычисляемых свойств}

Вы хотите определить доступный только для чтения атрибут как свойство, которое вычисляется при доступе к нему. Однако после того, как доступ произойдет, значение должно кешироваться и не пересчитываться при следующих запросах.

Дескпритор -- класс, который реализует три ключевые операции доступа к атрибутам (получения, присваивания и удаления) в форме специальных методов \verb|__get__()|, \verb|__set__()| и \verb|__delete__()|.

Эффективный путь определинея ленивых атрибутов -- это использование \emph{класса-дескриптора} \cite[\strbook{271}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# дескрипторный класс
class lazyproperty:
    def __init__(self, f: t.Callable):
        self.f = f
        
    def __get__(self, instance, cls):
        if instance is None:
            # Если дескриптор вызывать через объект управляющего класса,
            # например как Circle.area, то instance=None и будет возвращена
            # ссылка на объект экземпляра дескриптора
            return self  
        else:
            value = self.f(instance)
            setattr(instance, self.f.__name__, value)
            return value
\end{lstlisting}

Чтобы использовать этот код, вы можете применить его в классе
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Circle:
    def __init__(self, radius: float):
        self.radius = radius
        
    @lazyproperty
    def area(self):
        print("Computing area")
        return math.pi * self.radius ** 2
    
    @lazyproperty
    def perimeter(self):
        print("Computing perimeter")
        return 2 * math.pi * self.radius
\end{lstlisting}

Вот пример использования
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> c = Circle(radius=4.0)
>>> c.area
# Computing area
# 50.26...
>>> c.area  # 50.26...
\end{lstlisting}

Во многих случаях цель применения лениво вычисляемых атрибутов заключается в увеличении производительности. Например, вы можете избежать вычисления значений, если только они действительно где-то не нужны.

Когда дескриптор помещается в определение класса, его методы \verb|__get__()|, \verb|__set__()| и \verb|__delete__()| задействуются при доступе к атрибуту. Но если дескриптор определяет только метод \verb|__get__()|, то у него намного более слабое связывание, нежели обычно. В частности, метод \verb|__get__()| срабатывает, \emph{только если атрибут}, к которому осуществляется доступ, \emph{отсутствует в словаре экзмпляра} управляющего класса (в данном случае класса \texttt{Circle}) \cite[\strbook{272}]{beazley:python_cookbook-2019}.

Класс \texttt{lazyproperty} использует это так: он заставляет метод \verb|__get__()| сохранять вычисленное значение в экземпляре, используя то же имя, что и само свойство. С помощью этого значение сохраняется в словаре экземпляра и \underline{отключает будущие вычисления свойства}.

Возможный недостаток этого рецепта в том, что вычисленное значение становится изменяемым после создания. То есть значение, например, свойства \texttt{area} можн затереть.

Если это проблема, вы можете использовать немного менее эффективное решение \cite[\strbook{273}]{beazley:python_cookbook-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def lazyproperty(func):
    name = "_lazy_" + func.__name__
    @property
    def lazy(self):
        if hasattr(self, name):
            return getattr(self, name)
        else:
            value = func(self)
            setattr(self, name, value)
            return value
    return lazy
\end{lstlisting}

В этом случае операции присваивания недоступны
\begin{lstlisting}[
style = ironpython,
numbers = none
]
>>> c = Circle(4.0)
>>> c.area
Computing area
50.26...
>>> c.area
50.26...
>>> c.area = 25  # Поднимется исключение AttributeError
\end{lstlisting}

В этом случае все операции получения значения проводятся через функцию-геттер свойства. Это менее эффективно, чем простой поиск значения в словаре экземпляра.

Еще можно просто задекорировать свойство декоратором \texttt{lru\_cache}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import lru_cache

class Circle:
    def __init__(self, radius: float):
        self.radius = radius
        
    @property
    @lru_cacha
    def area(self):
        print("Computing area")
        return math.pi * self.radius ** 2
        
    @property
    @lru_cache
    def perimeter(self):
        print("Computing perimeter")
        return 2 * math.pi * self.radius
        
        
>>> circle = Circle(4.0)
>>> circle.area
# Computing area
# 50.26...
>>> circle.area  # 50.26...
\end{lstlisting}


\section{Определение более одного конструктора в классе}

Вы пишите класс и хотите, чтобы пользователи могли создавать экземпляры не только лишь единственным способом, предоставленным \verb|__init__()|.

Чтобы определить класс с более чем одним конструктором, вы должны использовать метод класса
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Circle:
    def __init__(self, radius: float, color: str = "black"):
         """
         Первичный конструктор
         """
         self.radius = radius
         self.color = color
    
    @classmethod
    def make_default_circle(cls):
        """
        Альтернативный конструктор. Конструктор тривиального класса
        """
        return cls(radius=1.0, color="red")
    
    @property
    @lru_cache
    def area(self):
        print("Computing area")
        return math.pi * self.radius ** 2
    
    @property
    @lru_cache
    def perimeter(self):
        print("Computing perimeter")
        return 2 *  math.pi * self.radius
    
    def __repr__(self):
        return f"{type(self).__name__}(radius={self.radius}, color={self.color})"
    
    def get_params(self) -> dict:
        return {"raidus": self.radius, "color": self.color}
\end{lstlisting}

Одно из главных применений \emph{методов класса} -- это определение \emph{альтренативных конструкторов} \cite[\strbook{294}]{beazley:python_cookbook-2019}. 

При определении класса с множественными конструкторами необходимо делать функцию \verb|__init__()| максимально простой -- она должна просто присваивать атрибутам значения. А вот уже альтернативные конструкторы будут вызываться при необходимости выполнения продвинутых операций.

Если требуется вызывать методы по имени, то можно воспользоваться \texttt{operator.methodcaller()}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import operator

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
        
    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

p = Point(2, 3)
operator.methodcaller("distance", 0, 0)(p)
\end{lstlisting}

Функция \texttt{methodcaller()} может быть полезна, например, в следующем случае
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class Person:
    def __init__(self, name: str, job: str):
        self.name = name
        self.job = job
        
    def action_1(self):
        return "Action-1"
        
    def action_2(self):
        return "Action-2"
        
    def action_N(self):
        return "Action-N"
\end{lstlisting}

Вызвать действие теперь можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def make(*, obj, action: str):
    if hasattr(obj, action):
        return methodcaller(action)(obj)
    else:
        raise ValueError(f"Object '{type(obj).__name__}' has't action '{action}' ...")
        
leor = Person(name="Leor", job="ML")   
make(obj=leor, action="action_1")  # Action-1
make(obj=leor, action="action_2")  # Action-2
make(obj=leor, actin="action_10")  # ValueError
\end{lstlisting}

Без \texttt{methodcaller()} пришлось бы писать что-то вроде
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def bad_make(*, obj, action: str):
    if action == "action_1":
        obj.action_1()
    elif action == "action_2":
        obj.action_2()
    ...
\end{lstlisting}

\section{Класс загрузчик данных}

Иногда бывает удобно использовать свой загрузчик. Например, когда нужно работать с большими npz-файлами временных рядов
\begin{lstlisting}[
style = ironpython,
numbers = none
]
import pathlib2
import typing as t

class DataLoader:
    def __init__(self, data_dir):
        self.files = list(pathlib2.Path(data_dir).glob("*.npz"))
        
    def __getitem__(self, key):
        return self.read(self.files[key])
        
    def __iter__(self):
        yield from map(lambda file: self.read(file), self.files)
        
    def __len__():
        return len(self.files)
        
    def read(self, filepath):
        loader = np.load(filepath, allow_pickle=True)
        
        X = loader["X"]
        index = loader["index"]
        columns = loader["columns"]
        y = loader["y"]
        
data = DataLoader("./data")
\end{lstlisting}

\section{Параметрические декораторы}

Требуется создать функцию-декторатор, которая принимала бы аргументы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps
import logging

# level, name и message -- это параметры декоратора
def logged(level, name=None, message=None):
    # это обычный декоратор, аргумент func которого ссылается на декорируемую функцию
    def decorate(func: t.Callable):
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__
        
        @wraps(func)
        # args и kwargs -- это аргументы задекорированной функции
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)
        return wrapper
    return decorate
    
# Пример использования
@logged(logging.DEBUG)  # -> @decorate: add = deocrate(add) -> wrapper || add -> wrapper
def add(x, y):
    return x + y
    
@logged(logging.CRITICAL, "example")
def spam():
    print("Spam!")
\end{lstlisting}

Можно считать, что после объявления функции \texttt{add} вместо выражения \verb|@logged(logging.DEBUG)| стоит \verb|@decorate|, но при этом еще доступна переменная \verb|level| со значением \verb|@logging.DEBUG|, а также переменные \texttt{name} и \texttt{message} со значением \texttt{None}. Аргумент функции \texttt{decorate} получает ссылку на декорируемую функцию \texttt{add}. Затем локальные переменные \texttt{logname}, \texttt{log} и \texttt{logmsg} получают значения, после чего возвращается ссылка на вложенную функцию \texttt{wrapper}. Таким образом, при вызове функции \texttt{add} будет вызываться функция \texttt{wrapper}.

\section{Пользовательские исключения}

Можно не просто наследовать пользовательский класс исключения от класса \verb|Exception|, задавать сообщения по умолчанию и пр.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
class PathToProblemError(Exception):
    """
    Incorrect path to problem
    """
    
    def __init__(
        self,
        message="Error! Incorrect path to problem: {}",
        *,
        incorrect_path_to_problem="",
    ):
        super().__init__(message.format(incorrect_path_to_problem))
\end{lstlisting}

\section{Определение декоратора, принимающего необязательный аргумент}

Вы хотели бы написать один декоратор, который можно было бы использовать и без аргументов -- \verb|@decorator|, и с необязательными аргументами \verb|@decorator(x, y, z)| \cite[\strbook{339}]{beazley:python_cookbook-2019}.

\begin{lstlisting}[
style = ironpython,
numbers = none
]
from functools import wraps, partial
import logging

def logged(func=None, *, level=logging.DEBUG, name=None, message=None):
    if func is None:
        return partial(logged, level=level, name=name, message=message)
        
    logname = name if name else func.__module__
    log = logging.getLogger(logname)
    logmsg = message if message else func.__name__
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        log.log(level, logmsg)
        return func(*args, **kwargs)
    return wrapper
    
# Пример использования
@logged
def add(x, y):
    return x + y
    
@logged(level=logging.CRITICAL, name="example")
def spam():
    print("Spam")
\end{lstlisting}

Этот рецепт просто заставляет декоратор одинаково работать и с дополнительными скобками, и без.

Чтобы понять принцип работы кода, вы должны четко понимать то, как декораторы применяются к фукнциям, а также условия их вызова. Для простого декоратора, такого как этот
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@logged  # logged(func=add, ...)
def add(x, y):
    return x + y
\end{lstlisting}
последовательность вызова будет такой
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def add(x, y):
    return x + y
    
add = logged(add)
\end{lstlisting}

В этом случае обертываемая функция просто передается в \texttt{logged} первым аргументом. Поэтому в решении первый аргумент \texttt{logged()} -- это обертываемая функция. Все остальные аргументы должны иметь значения по умолчанию.

Для декоратора, принимающего аргументы, такого как этот
\begin{lstlisting}[
style = ironpython,
numbers = none
]
@logged(level=logging.CRITICAL, name="example")  # logged(func=None, ...)
def spam():
    print("Spam")
\end{lstlisting}
последовательность вызова будет такой
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def spam():
    print("Spam")

spam = logged(level=logging.CRITICAL, name="example")(spam)
\end{lstlisting}

При первичном вызове \verb|logged()| обертываемая функция не передается. Так что в декораторе она должна быть необязательной. Это, в свою очередь, заставляет другие аргументы быть именованными. Более того, когда аргументы переданы, декоратор должен вернуть функцию, которая принимает функцию и оборачивает ее. Чтобы сделать это, в решении используется хитрый трюк с \texttt{functools.partial}. Если точнее, он просто возвращает частично примененную версию себя, где все аргументы зафиксированы, за исключением обертываемой функции.

Таким образом, при повторном вызове функции \texttt{logged} через \texttt{partial} вызов будет выглядеть следующим образом
\begin{lstlisting}[
style = ironpython,
numbers = none
]
spam = logged(func=spam, level=logging.CRITICAL, name="example", message=None)
\end{lstlisting}

Одна из особенностей декораторов в том, что они \underline{применяются только один раз}, во время \emph{определения} функции \cite[\strbook{342}]{beazley:python_cookbook-2019}

\section{Параллельное программирование}

Библиотека \texttt{concurent.futures} предоставляет класс \texttt{ProcessPoolExecutor}, который может быть использован для выполнения тяжелых вычислительных задач в \emph{отдельно запущенных экземплярах интерпретатора Python} \cite[\strbook{498}]{beazley:python_cookbook-2019}.

<<Под капотом>> \texttt{ProcessPoolExecutor} создает $ N $ независимо работающих интерпретаторов Python, где $ N $ -- это количество доступных обнаруженных в системе CPU. Пул работает до тех пор, пока не будет выполнена последняя инструкция в блоке \texttt{with}, после чего пул процессов завершается. Однако программа будет ждать, пока вся отправленная работа не будет сделана.

Чтобы получить результат от экземпляра Future, нужно вызвать метод \texttt{result()}. Это вызовет \emph{блокировку} на время, пока результат не посчитается и не будет возвращен пулом.

Несколько вопросов, связанных с пулами процессов:
\begin{itemize}
	\item Этот прием распараллеливания работает только для задач, которые легко раскладываются на независимые части,
	
	\item Работа должна отправляться в форме простых функций,
	
	\item Аргументы функций и возвращаемые значения должны быть совместимы с pickle. Работа выполняется в отдельном интерпретаторе при использовании межпроцессной коммуникации. Так что данные, которыми обмениваются интерпретаторы, должны \emph{сериализоваться},
	
	\item Пулы процессов в Unix создаются с помощью системного вызова \texttt{fork()}. Он создает клон интерпретатора Python, включая все состояние программы на момент копирования. В Windows запускается независимая копия интерпретатора, которая не клонирует состояние,
	
	\item Нужно с великой осторожностью объединять пулы процессов с программами, которые используют потоки.
\end{itemize}

\subsection{Пример использования пула потоков}

Требуется для каждой переменной в MILP-задаче описать контекст переменной через типы переменных, которые встречаются в тех ограничениях, в которые входит рассматриваемая переменная. Для примера пусть переменная входит в 3 ограничения. В первом ограничении кроме рассматриваемой переменной есть еще две: одна, скажем, вещественная, а другая целочисиленная. Во втором ограничении кроме рассматриваемой переменной есть еще 3 вещественные. А в третьем ограничении кроме рассматриваемой есть еще одна бинарная. Тогда для рассматриваемой переменной мы должны получить такой контекст: \verb|"{CONTINUOUS": 4, "BINARY": 1, "INTEGER": 1}|. Затем полученные контексты собираются в список словарей. На этом списке требуется построить кадр данных. В данном случае это можно сделать так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
pd.DataFrame.from_dict(ChainMap(*results), orient="index")  # ОЧЕНЬ МЕДЛЕННО!
\end{lstlisting}

Построение кадра данных на 26 000 контекстов занимает около 2-х минут. Оданко, если список \verb|results| разбить на пакеты, для каждого пакета построить кадр данных, собрать в список, а затем склеить с помощью \verb|pd.concat()|, то время построения снижается до 6 секунд
\begin{lstlisting}[
style = ironpython,
numbers = none
]
dfs = []
for batch_idx in range(math.ceil(len(results) / batch_size)):
    _part = results[batch_idx * batch_size : (batch_idx + 1) * batch_size]
    dfs.append(pd.DataFrame.from_dict(ChainMap(*_part), orient="index"))
    
_features = pd.concat(dfs, axis=0)
\end{lstlisting}

Каждое обращение к \verb|executor.submit| \emph{планирует выполнение} одного вызываемого объекта и возвращает экзмепляр \verb|Future|. Первый аргумент -- сам вызываемый объект, остальные -- передаваемые ему аргументы. 

Функция \verb|as_completed()| возвращает итератор, который отдает будущие объекты по мере их завершения: \verb|as_completed()| возвращает \emph{только уже завершенные} будущие объекты.

\begin{lstlisting}[
style = ironpython,
numbers = none
]
def _get_var_context_types(
	self,
	conss: t.Iterable[t.Tuple[str, dict]],
	var_name: str,
) -> dict:
	"""
	Gets var types in context current var. For example,
	"y_var_1" -> {"CONTINUOUS": 8, "INTEGER": 4, "BINARY": 0}
	"""
	cons_name: str
	cons: dict
	_var_types: t.List[str] = []
	var_context_types: t.Dict[str, int]
	
	for cons_name, cons in conss:
		if var_name in cons:
		_var_types.extend(
			[
				self._var_name_to_var_type.get(_var_name)
				for _var_name in cons.keys()
				if var_name != _var_name
			]
		)
	
	if not _var_types:
		var_context_types = {VAR_TYPE_CONTINUOUS: 0, VAR_TYPE_BINARY: 0, VAR_TYPE_INTEGER: 0}
	else:
		var_context_types = Counter(_var_types)
	
		not_represented_var_types: t.Set[str] = {
			VAR_TYPE_CONTINUOUS,
			VAR_TYPE_BINARY,
			VAR_TYPE_INTEGER,
		}.difference(set(_var_types))
	
		if not_represented_var_types:
			for var_type in not_represented_var_types:
				var_context_types.update({var_type: 0})
	
	return {var_name: var_context_types}

def build_var_context_types(
	self,
	var_names: t.List[str],
	conss: t.Iterable[t.Tuple[str, dict]],
	batch_size: int = 2_000,
	max_n_threads: int = 100,
) -> pd.DataFrame:
	"""
	Builds features for var context types in parallel mode
	"""
	with ThreadPoolExecutor(max_workers=max_n_threads) as executor:
		to_do: t.List[Future] = []
	
		for var_name in tqdm(var_names):
			future: Future = executor.submit(self._get_var_context_types, conss, var_name)
			to_do.append(future)
	
		results: t.List[dict] = []
		for future in as_completed(to_do):
			result = future.result()
			results.append(result)
	
	dfs: t.List[pd.DataFrame] = []
	for batch_idx in tqdm(range(math.ceil(len(results) / batch_size))):
		_part = results[batch_idx * batch_size : (batch_idx + 1) * batch_size]
		dfs.append(pd.DataFrame.from_dict(ChainMap(*_part), orient="index"))
	
	_features = pd.concat(dfs, axis=0)
	_features.columns = [f"{col_name.lower()}_type_context" for col_name in _features.columns]
	
	return _features
\end{lstlisting}

\subsection{Процессы, потоки и GIL в Python}

Выдержка из книги Л. Рамальо \cite[\strbook{650}]{ramalho:python-2022}:
\begin{itemize}
	\item Каждый \emph{экземпляр интрепретатора Python} является \emph{процессом}. Дополнительные процессы Python можно запускать с помощью библиотек \texttt{multiprocessing} или \texttt{concurrent.futures}. 
	
	\item Интерпретатор Python использует единственный поток, в котором выполняется и пользовательская программа, и сборщик мусора. Для запуска дополнительных потоков предназначены библиотеки \texttt{threading} и \texttt{concurrent.futures}.
	
	\item Только один поток может выполнять Python-код, и от числа процессорных ядер это не зависит.
	
	\item Любая стандартная библиотечная функция Python, делающая системный вызов, освобождает GIL. Сюда относятся все функции, выполняющие дисковый ввод-вывод, сетеовой ввод-вывод, а также \texttt{time.sleep()}. Многие счетные функции в библиотеках numpy/scipy, а также функции сжатия и распаковки из модулей \texttt{zlib} и \texttt{bz2} также освобождают GIL.
	
	\item Влияние GIL на сетевое программирование с помощью потоков Python сравнительно невелико, потому что функции ввода-вывода освобождают GIL, а чтение или запись в сеть всегда подразумевает высокую задержку по сравнению с чтением-записью в память. Следовательно, каждый отдельный поток все равно тратит много времени на ожидание, так что их выполнение можно чередовать без заметного снижения общей пропускной способности.
	
	\item Состязание за GIL замедляет работу счетных потоков в Python. В таких случаях последовательный однопоточный код проще и быстрее.
	
	\item Для выполнения счетного Python-кода на нескольких ядрах нужно использовать несколько процессов Python.
\end{itemize}

Деталь реализации CPython. В CPython, из-за глобальной блокировки интерпретатора, в каждый момент времени Python-код может выполняться только одним потоком (хотя некоторые высокопроизводительные библиотеки умеют обходить это ограничение). Если вы хотите, чтобы приложение более эффективно использовало вычислительные ресурсы многоядерных машин, то пользуйтесь модулем \texttt{multiprocessing} или классом \texttt{concurrent.futures.ProcessPoolExecutor}. Однако многопоточное выполнение все же является вполнен пригодной моделью, если требуется одновременно выполнять несколько задач с большим объемом ввода-вывода \cite[\strbook{652}]{ramalho:python-2022}.

По умолчанию \emph{сопрограммы} вместе с \emph{управляющим циклом событий}, который предоставляется каркасом асинхронного программирования, работают в \emph{одном потоке}, поэтому GIL не оказывает на них никакого влияния. Можно использовать несколько потоков в асинхронной программе, но рекомендуется, чтобы и цикл событий, и все сопрограммы исполнялись в одном потоке, а дополнительные потоки выделялись для специальных задач.



\subsection{Глобальная блокировка интерпретатора}

Интерпретатор защищен так называемой глобальной блокировкой интерпретатора (GIL), которая позволяет \emph{только одному потоку} Python выполняться в любой конкретный момент времени \cite[\strbook{503}]{beazley:python_cookbook-2019}.

Наиболее заметный эффект GIL в том, что многопоточные программы Python не могут полностью воспользоваться преимуществами многоядерных процессоров (тяжелые вычислительные задачи, использующие больше одного потока, работают только на одном ядре процессора) \cite[\strbook{503}]{beazley:python_cookbook-2019}.

{\color{blue}GIL влияет только на программы, сильно нагружающие CPU} (то есть те, в которых вычисления доминируют). Если ваша программа в основном занимается вводом-выводом, что типично для сетевых коммуникаций, потоки часто являются разумным выбором, потому что они проводят большую часть времени в ожидании.

\section{Проверка сущестования путей в \texttt{dataclass}}

Для того чтобы при чтении конфигурационного файла проекта, выполнялась проверка существования путей, следует задекорировать класс-схему следующим образом \url{https://harrisonmorgan.dev/2020/04/27/advanced-python-data-classes-custom-tools/}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def validated_dataclass(cls):
	"""
	Class decorator for validating fields
	"""
	cls = dataclass(cls)

	def _set_attribute(self, attr, value):
		for field in fields(self):
			if field.name == attr and "validator" in field.metadata:
				value = field.metadata["validator"](value)
				break

		object.__setattr__(self, attr, value)
		cls.__setattr__ = _set_attribute

		return cls


@validated_dataclass
class Paths:
	path_to_test_lp_file: str = field(metadata={"validator": check_existence_path})
	path_to_set_file: str = field(metadata={"validator": check_existence_path})
	path_to_output_dir: str = field(metadata={"validator": check_existence_path})

def check_existence_path(path: str):
	path = pathlib2.Path(path)
	if not path.exists():
		raise FileNotFoundError(f"Path {path} not found ...")
	
	return path
\end{lstlisting}

\section{Приемы работы с библиотекой SPyQL}

SPyQL \url{https://github.com/dcmoura/spyql}  -- это утилита командной строки, позволяющая писать SQL-подобные запросы к csv-, json-файлам, с использованием выразительных средств Python.

Прочитать csv-файл и вывести первые две записи в json-формате
\begin{lstlisting}[
style = bash,
numbers = none
]
$ spyql "SELECT * FROM csv LIMIT 2 TO json(indent=2)" < features_a78cbead_bin.csv
{
	"var": "alpha_tu_0_1_12_1",
	"scenario": "a78cbead_bin",
	"varBinaryOriginal": 1,
	"varTypeTrans": 0,
	"varStatus": 1,
	"varMayRoundUp": 0,
	"varMayRoundDown": 0,
	"varMayIsActive": 1,
	"varIsDeletable": 0,
	"varIsRemovable": 0,
	"varObj": 0.0,
	"varPseudoSol": -0.0,
	"NLocksDown": 1,
	"NLocksUp": 1,
	"IsTransformed": 1,
	"multaggrConstant": 0,
	"varAggrScalar": 0,
	"varAggrConstant": 0,
	"varMultaggrNVars": 0,
	"varBestBound": -0.0,
	"varWorstBound": 1.0,
	"varBranchFactor": 1,
	"varBranchPriority": 0,
	"varBranchDirection": 3,
	"varNImpls0": 0,
	"varNImpls1": 0,
	"varGetNCliques0": 0,
	"varGetNCliques1": 0,
	"varConflictScore": 1e-12,
	"varAvgInferenceScore": 87.0136,
	"relaxSolVal": 0.458516,
	"varImplRedcost0": 0.0,
	"varImplRedcost1": 0.0,
	"varPseudocostScore": 0.248279,
	"equalToLb": 0,
	"equalToUb": 0,
	"target": 1
}
...
\end{lstlisting}

Прочитать csv-файл, сгруппировать по полю \texttt{varStatus}, а затем из результата выбрать строки, в которых \texttt{varStatus > 2}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cat features_a78cbead_bin.csv \
    | spyql "SELECT varStatus AS status, count_agg(*) AS count FROM csv GROUP BY 1 TO spy" \
    | spyql "SELECT * FROM spy WHERE status > 2 ORDER BY 2 DESC TO pretty"
  
  status    count
 --------  -------
     3     8361
     4      552
\end{lstlisting}


\section{Приемы работы с библиотекой Pandas}

\subsection{Общие замечания}

Как отмечается в библиотеке \verb*|pandarallel| \url{https://nalepae.github.io/pandarallel/} основной недостаток библиотеки \verb|pandas| заключается в том, что она может \emph{\color{red}утилизировать только одно ядро процессора}, даже если доступно несколько ядер.

Библиотека \verb|pandarallel| может использовать все доступные ядра процессора, однако ей требуется в два раза больше памяти, чем \verb|pandas|. Не рекомендуется использовать \verb|pandarallel|, если \verb|pandas|-данные не помещаются в память. В этом случае лучше подойдет Spark.

Библиотека Spark позволяет работать с данными, которые \emph{значительно превышают доступную память} (Handle data much bigger than your memory) и может распределять вычисления по нескольким узлам кластера.

\subsection{Советы по оптимизации вычислений}

В ситуации, когда необходимо итерирование, более быстрым способом итерирования строк будет использование метода \texttt{.iterrows()}. Метод \texttt{.iterrows()} оптимизирован для работы с кадрами данных, и хотя это наименее эффективный способ большинства страндартных функций, он дает значительное улучшение, по сравнению с базовым итерированием \cite[\strbook{328}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
haversine_series = []
for index, row in df.iterrows():
    haversine_series.append(haversine(...))
df["distance"] = haversin_series
\end{lstlisting}

Однако метод \verb|.iterrows()| не сохраняет типы по строкам. Если требуется сохранять типы атрибутов строки, то лучше воспользоваться методом \verb|.itertuples()|, который поддреживает итерирование по строкам в виде именных кортежей. Кроме того часто \verb|.itertuples()| оказывается быстрее \verb|.iterrows()|.

Более эффктивным способом является использование метода \texttt{.apply()}, который применяет функцию вдоль определеной оси (вдоль строк или вдоль столбцов) кадра данных.

Хотя метод \texttt{.apply()} также по своей сути \emph{\color{red}перебирает строки} (!), он делает это намного эффективнее, чем метод \texttt{.iterrows()}, используя ряд внутренних оптимизаций, например, применяя итераторы, написанные на Cython \cite[\strbook{328}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["distance"] = df.apply(lambda row: haversine(..., ..., row["latitude"], row["longitude"]), axis=1)
\end{lstlisting}

Но гораздо эффективнее задействовать \emph{векторизацию} и передать не скаляры, а столбцы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["distance"] = haversine(..., ..., df["latitude"], df["longitude"])
\end{lstlisting}

Если скорость имеет наивысший приоритет, можно вместо серий использовать numpy-массивы. Как и pandas, numpy работает с массивами. однако она освобождена от дополнительных вычислительных затрат, связанных с операциями в pandas, такими как индексирование, проверка типов данных и т.д. В результате операции над массивами numpy могут выполняться значительно быстрее, чем операции над объектами \texttt{Series}.

Массивы numpy можно использовать вместо объектов \texttt{Series}, когда дополнительная функциональность, предлагаемая объектами \texttt{Series}, не является критичной. Например, векторизованная реализация функции \texttt{haversine} фактически не использует индексы в сериях \texttt{langitude} и \texttt{latitude}, и поэтому отсутствие этих индексов не приведет к нарушению работы функции
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["distance"] = haversine(..., ..., df["latitude"].values, df["longitude"].values)
\end{lstlisting}

Оптимизацию числовых столбцов можно выполнить с помощью \emph{понижающего преобразования}, используя функцию \texttt{pd.to\_numeric}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.select_dtypes(np.dtype("int64")).apply(
    pd.to_numeric,  # функция, которая применяется к int-столбцам
    downcast="unsigned"  # аргумент функции pd.to_numeric
)
\end{lstlisting}

В значительной степени снижение потребления памяти будет зависеть от оптимизации столбцов типа \texttt{object}. Тип \texttt{object} представляет значения, использующие питоновские объекты-строки, отчасти это обусловлено отсутствием поддержки пропущенных строковых значений в numpy. Python не предполагает точной настройки способа хранения значений в памяти. Это ограничение приводит к тому, что строки хранятся фрагментированно, это потребляет больше памяти и замедляет доступ. Каждый элемент в столбце типа \texttt{object} является, по сути, указателем, который содержит <<адрес>> фактического значения в памяти \cite[\strbook{347}]{heydt:pandas-2019}.

Преобразовать столбец типа \texttt{object} в столбец типа \texttt{category} можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["object_col_name"].astype("category")
\end{lstlisting}

Хотя каждый указатель занимает 1 байт памяти, каждое фактическое строковое значение использует такой объем памяти, какой строка использовала бы, если бы отдельно хранилась в Python.

Тип \texttt{category} под капотом для представления строковых значений в столбце вместо исходных использует целочисленные значения. Для этого создается отдельный словарь, в котором исходным значениям сопоставлены целочисленные значения. Это сопоставление будет полезно для столбцов с небольшим числом уникальных значений.

Рекомендуется придерживаться типа \texttt{category} при работе с такими столбцами \texttt{object}, в которых менее 50\% значений являются уникальными. Если все значения в столбце являются уникальными, тип \texttt{category} будет использовать б\emph{о}льший объем памяти. Это обусловлено тем, что в столбце, помимо целочисленных кодов, представляющих категории, храняться все исходные строковые значения.


\subsection{Рецепты}

\subsubsection{Приемы работы с кадрами данных}

Построить кадр данных заполненный \verb|NaN|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df = pd.DataFrame(np.nan, index=range(10), columns=["col1", "col2", "col3"])
\end{lstlisting}

Ремарка: с помощью \verb|scipy.sparse.scr_matrix| можно создавать огромные разреженные матрицы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from scipy.sparse import csr_matrix

mtx = csr_matrix((300_000, 30_000), dtype=np.int8)
\end{lstlisting} 

Еще для создания разреженных матриц можно воспользоваться функцией \verb|scipy.sparse.lil_matrix|, которая создает разреженные матрицы инкрементно (поэтапно) и представляет список списков разрежнных матриц.

Например, индексы столбцов в строке номер 100, элементы которых равны единице можно получить так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
from scipy.sparse import lil_matrix

mtx = lil_matrix((300_000, 30_000), dtype=np.int8)
mtx[100:300, 200:250] = 1
(mtx[100, :] == 1).indices
\end{lstlisting}

Применить регулярное выражение к строковому атрибуту кадра данных, а затем сделать его вещественным можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["col_name"].str.extract(r"^.*?(\d+[.]?\d+)s$").astype(np.float32)
\end{lstlisting}

Вывести точную информацию об использовании памяти
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
df.info(memory_usage="deep")
"""
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1000 entries, 0 to 999
Data columns (total 3 columns):
#   Column  Non-Null Count  Dtype
---  ------  --------------  -----
0   key1    1000 non-null   float64
1   key2    1000 non-null   int64
2   color   1000 non-null   object
dtypes: float64(1), int64(1), object(1)
memory usage: 75.3 KB
"""
\end{lstlisting}

Посмотреть какие строки значений (а не индексы) кадра данных попали в ассоциированные группы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").groups.keys()
\end{lstlisting}

Заполнить пропущенные значения групповым средним по столбцу. Метод \verb|apply| в случае сгруппированных объектов применяет переданную функцию (в данном случае анонимную) к каждой группе, а внутри группы операции применяются вдоль указанных осей
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Нужно отобрать поля, к которым будет применяться функция
df["year"] = df.groupby("color")["year"].apply(  # .loc[:, "year"] НЕ РАБОТАЕТ!
    lambda group: group.fillna(group.mean())
)
\end{lstlisting}

Для того чтобы метод \verb|apply| корректно работал на объекте групп нужно указать с какими полями мы будем работать
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Указываем поля "year" и "mark"
df.groupby("model_car_id")[["year", "mark"]].appply(lambda gr: gr.fillna(gr.mean()))
# или
df.groupby("model_car_id")[["year", "mark"]].transform(lambda gr: gr.fillna(gr.mean()))
\end{lstlisting}

Метод \verb|transform| объекта GroupBy применяет указанную функцию \emph{к каждой группе}, а затем помещает результаты в нужные места \cite[\strbook{291}]{mckinney:pandas-2015}.

В самом простом случае метод \texttt{transform} применяет переданную функцию вдоль указанного направления и для каждого элемента возвращает результат преобразования, а в случае если метод \verb|transform| вызывается на GroupBy-объекте, то метод применяет указанную функцию для каждой группы и <<заменяет>> каждый элемент своей группы групповым аггрегатом или результатом преобразования (причем для каждого столбца вычисляется свой аггрегат)
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# каждый элемент групп будет заменен количеством элементов в группе
df.groupby("color")["elems"].transform(len)
\end{lstlisting}

Другими словами, метод \verb|transform| на сгруппированном объекте в том подкадре данных, который возвращается методом, каждый элемент группы <<заменяет>> групповым аггрегатом (или результатом преобразования), а метод \verb*|apply| просто применяет указанную функцию \emph{к каждой группе} \cite[\strbook{292}]{mckinney:pandas-2015} и склеивает результаты, т.е. возвращает результат для каждой группы
\begin{lstlisting}[
style = ironpython,
numbers = none
]
$ df.groupby("color")[["a", "e"]].transform(lambda gr: gr.mean())
# В столбце 'a' для элементов, попавших в группу, среднее было 49.377..., поэтому эти элементы заменены на соответсвующее групповое среднее
              a          e
0     49.377209  49.611246
1     49.950178  49.839233
2     49.730188  48.043373
3     49.730188  48.043373
4     49.950178  49.839233
...         ...        ...
9995  49.377209  49.611246
9996  49.377209  49.611246
9997  49.377209  49.611246
9998  49.950178  49.839233
9999  49.950178  49.839233
$ df.groupby("color")[["a", "e"]].apply(lambda gr: gr.mean())
               a          e
color
blue   49.730188  48.043373
green  49.950178  49.839233
red    49.377209  49.611246
\end{lstlisting}

Получается, что ключевое отличие метода \verb|transform| от метода \verb|apply| на GroupBy-объектах заключается в том, что \verb|transform| \emph{преобразует элементы группы}, а метод \verb|apply| просто разбивает кадр данных на группы, применяет указанную функцию к каждой группе, а затем пытается склеить результаты, то есть это что-то вроде концепции map-reduce.

Например, если требуется создать новый столбец, элементы которого помечаются меткой \verb|"old"|, если элемент меньше группового среднего и -- меткой \verb|"new"|, если элемент больше группового среднего, то можно решить эту задачу с помощью метода \verb|transform|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df["avg_a"] = df.groupby("color")["a"].transform(np.mean)
df["age"] = np.where(df["a"] < df["avg_a"], "old", "new")
\end{lstlisting}

То есть еще раз, метод \verb|transform| применяет указанную функцию (\verb|np.mean|) к каждой группе, а затем возвращает подкадр данных, в котором каждый элемент заменяется групповым аггрегатом.

Найти среднее и страндартное отклонение по группам для вещественных столбцов кадра данных
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("label")[
    df.select_dtypes(np.dtype("float64")).columns
].agg([np.mean, np.std]).stack()
\end{lstlisting}

При проведении разведочного анализа данных лучше всего сначала загрузить данные и исследовать их с помощью запросов/логического отбора. Затем создайте индекс, если ваши данные поддерживают его или если вам требуется повышенная производительность \cite[\strbook{115}]{heydt:pandas-2019}. Операции поиска с использованием индекса обычно выполняются быстрее. В силу лучшей производительности выполнение поиска по индексу (в тех случаях, когда это возможно) обычно является оптимальным решением. Недостаток использования индекса заключается в том, что потребуется время на его создание, кроме того, он занимает больше памяти.

Выполнить слияние кадров данных можно с помощью функции \texttt{pd.merge} или метода \texttt{.merge}. По умолчанию слияние выполняется по \emph{общим меткам столбцов}, однако сливать кадры данных можно и \emph{по строкам с общими индексами} \cite[\strbook{230}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Слияние по строкам
# Нужно задать оба параметра!
left.merge(right, left_index=True, right_index=True)
\end{lstlisting}

Кроме того, библиотека pandas предлагает метод \texttt{.join()}, который можно использовать для выполнения соединения с помощью \emph{индексных меток} двух объектов \texttt{DataFrame} (вместо значений столбцов) \cite[\strbook{232}]{heydt:pandas-2019}
\begin{lstlisting}[
style = ironpython,
numbers = none
]
# Слияние по строкам
# Здесь предполагается, что кадры данных имеют
# дублирующиеся имена столбцов, поэтому мы задаем lsuffix и rsuffix
left.join(right, lsuffix="_left", rsuffix="_right")
\end{lstlisting}

\remark{
Метод \texttt{.join()} по умолчанию используется \emph{внешнее соединение}, в отличие от метода \texttt{.merge()}, в котором по умолчанию применяется \emph{внутренее соединение}.
}

\emph{Состыковка} (stack) помещает уровень индекса столбцов в новый уровень индекса строк
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df = pd.DataFrame({
    "a": [1, 2],
    "b": [100, 200]
})
"""
     a    b
one  1  100
two  2  200
"""
df.stack()
"""
one  a      1
	   b    100
two  a      2
 	   b    200
"""
df.loc[("one", "b")]  # 100
\end{lstlisting}

Состыковку удобно применять к результатам аггрегации на группах
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
df.groupby("color")[["key1", "key4"]].agg([np.mean, np.std])
"""
           key1            key4
           mean       std  mean        std
color
blue   0.904027  0.508690  73.5  21.920310
green -0.493756  1.025554  65.0   9.899495
red   -0.399363       NaN  55.0        NaN
"""
# Состыковка
res = df.groupby("color")[["key1", "key4"]].agg([np.mean, np.std]).stack()
"""
                key1       key4
color
blue  mean  0.904027  73.500000
      std   0.508690  21.920310
green mean -0.493756  65.000000
      std   1.025554   9.899495
red   mean -0.399363  55.000000
"""
res.loc[("blue", "mean")]
"""
key1     0.904027
key4    73.500000
Name: (blue, mean), dtype: float64
"""
\end{lstlisting}

При построении агрегатов со сложным именем можно воспользоваться псевдонимами
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color")[["key1", "key2"]].agg([("MEAN", np.nanmean), ("STD", np.nanstd)]).stack()
"""
                key1      key2
color
blue  MEAN  0.544329  0.731969
green MEAN  0.231420  1.272040
       STD        NaN  1.255945
red   MEAN -0.399363  0.483054
"""
\end{lstlisting}

\emph{Расстыковка} (unstack) помещает самый внутренний уровень индекса строк в новый уровень индекса столбцов.

\emph{Расплавление} -- это тип организации данных, который часто называют преобразованием объекта DataFrame из <<широкого>> формата в <<длинный>> формат.
\begin{lstlisting}[
style = ironpython,
numbers = none
]
data = pd.DataFrame({
    "Name": ["Mike", "Mikal"],
    "Height": [6.1, 6.0],
    "Weight": [220, 185],
})
data
"""
     Name  Heigth  Weight
0    Mike     6.1     220
1  Mikael     6.0     185
"""
\end{lstlisting}

Расплавляем кадр данных
\begin{lstlisting}[
style = ironpython,
numbers = none
]
pd.melt(
    data,
    id_vars=["Name"],
    value_vars=["Height", "Weight"]
)
"""
     Name variable  value
0    Mike   Heigth    6.1
1  Mikael   Heigth    6.0
2    Mike   Weight  220.0
3  Mikael   Weight  185.0
"""
\end{lstlisting}

Получить данные по группе
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").get_group("blue")
\end{lstlisting}

Отфильтровать группы по условию. Если функция возвращает \texttt{True}, то группа включается в результат
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("color").filter(lambda group: group.col_name.count() > 1)
\end{lstlisting}

\subsubsection{Изменение настроек отдельной линии графика на базе кадра данных}
Чтобы изменить, например, толщину линии для какого-то заданного столбца кадра данных нужно получить доступ к перечню линий \verb|ax.get_lines()|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
fig, ax = plt.subplots(figsize=(15, 5))

df.plot(ax=ax, marker="o", style=["b--", "k-", "r-"])

for line in ax.get_lines():
    if line.get_label() == "col1":
        line.set_linewidth(3.5)
        line.set_alpha(0.8)
        line.set_marker("x")
\end{lstlisting}

\subsubsection{Использование регулярных выражений и обращений по имени группы при обработке строк}

Привести столбец строкового типа к числовому типу с предварительной подготовкой строки по регулярному выражению можно так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
pd.to_numeric(
    logs.loc[:, "time"].replace( # НЕ .str.replace!
        to_replace=r"^.*?(\d+).*?$",
        value=r"\1",  #  обращение к первой группе
        regex=True,
    )
)
\end{lstlisting}

\subsubsection{Работа с JSON. Комбинация \texttt{explode} и \texttt{pd.json\_normalize}}

Пусть есть такой кадр данных
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df = pd.DataFrame({
	"key1": [10],
	"color": ["red"],
	"records": [[  # list[dict]
	    {"solver_name": "highs", "mip_gap": 0.001, "obj_val": 1e+20},
	    {"solver_name": "cplex", "mip_gap": 0.015},
	    {"solver_name": "scip", "mip_gap": 0.003}
	]],
})

\end{lstlisting}

И требуется разобрать атрибут \verb|records|, то есть список словарей представить в виде набора строк кадра данных. Сделать это можно так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.loc[:, "records"].explode("records", ignore_index=True)
\end{lstlisting}

Теперь эту конструкцию можно обернуть функцией \verb*|pd.json_normalize| (несогласованные поля будут забиты \verb|NaN|)
\begin{lstlisting}[
style = ironpython,
numbers = none
]
pd.json_normalize(df.loc[:, "records"].explode("records"))
# out
#  solver_name  mip_gap       obj_val
# 0       highs    0.001  1.000000e+20
# 1       cplex    0.015           NaN
# 2        scip    0.003           NaN
\end{lstlisting}

\subsubsection{Кратная подстановка столбца}

Если требуется значения одного столбца подставить в несколько других столбцов, то можно поступить так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
columns: t.List[str] = [...]
df.loc[:, columns] = np.repeat(
    # значениями столбца "value" нужно заполнить другие столбцы
    df["value"].values.reshape(-1, 1),
    repeats=len(columns),
    axis=1
)
\end{lstlisting}

\subsubsection{Сборка строк группы в список словарей}

Пусть есть кадр данных
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df = pd.DataFrame({
    "key1": [0, 10, -1, -3, 5, 6],
    "key2": ["red", "green", "blue", "orange", "red", "blue"],
    "key3": [25, 0, -3, 10, 5, 1],
    "gr_key": [0] * 2 + [1] * 4,
})
"""
   key1    key2  key3  key0
0     0     red    25     0
1    10   green     0     0
2    -1    blue    -3     1
3    -3  orange    10     1
4     5     red     5     1
5     6    blue     1     1
"""
\end{lstlisting}

Требуется каждую строку группы \verb*|"gr_key"| представить в виде списка строк
\begin{lstlisting}[
style = ironpython,
numbers = none
]
df.groupby("gr_key").get_group(0)
"""
   key1   key2  key3  key0
0     0    red    25     0
1    10  green     0     0
"""

df.groupby("gr_key").get_group(1)
"""
   key1    key2  key3  key0
2    -1    blue    -3     1
3    -3  orange    10     1
4     5     red     5     1
5     6    blue     1     1
"""

df.groupby("gr_key")[["key1", "key2", "key3"]].apply(
    lambda gr: list(row[1].to_dict()
    for row in gr.iterrows())
)
"""
key0
0    [{'key1': 0, 'key2': 'red', 'key3': 25}, {'key...
1    [{'key1': -1, 'key2': 'blue', 'key3': -3}, {'k...
"""
\end{lstlisting}

К каждой группе (подкадру данных) применяется метод \verb*|iterrows()|, который возвращает итератор строк. Каждая строка представляет собой 2-кортеж <<индекс строки, строку-серию>>. Все строки группы собираются в список. Таким образом результат будет содрежать столько строк сколько уникальных значений содержит атрибут группировки.

\section{Полезные заметки по общим вопросам}

\subsection{Добавление ссылки на исполняемый файл}

Чтобы исполняемый файл \verb|./weather| можно было вызвать из любой точки системы, достаточно пробросить ярлык на этот исполняемый файл в \verb|/usr/local/bin/|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ sudo ln -s $(pwd)/weather /usr/local/bin
\end{lstlisting}





% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{beazley:python-2010}{\emph{Бизли Д.} Python. Подробный справочник. -- СПб.: Символ-Плюс, 2010. -- 864 с.}
	
	\bibitem{beazley:python_cookbook-2019}{\emph{Бизли Д.} Python. Книга рецептов. -- М.: ДМК Пресс., 2019. -- 648 с.}

    \bibitem{mckinney:pandas-2015}{\emph{Маккинли У.} Python и анализ данных, 2015. -- 482 с.}
	
	\bibitem{ramalho:python-2022}{\emph{Рамальо Л.} Python -- к вершинам мастерства: Лаконичное и эффективное программирование. -- М.: МК Пресс, 2022. -- 898 с.}
	
	\bibitem{heydt:pandas-2019}{\emph{Хейдт М., Груздев А.} Изучаем pandas. -- М.: ДМК Пресс, 2019. -- 682 с.}
	
	\bibitem{hostmann:scala-2013}{\emph{Хостманн К.} Scala для нетерпеливых. -- М.: ДМК Пресс, 2013. -- 408 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

%\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
